CCS PCM C Compiler, Version 4.119, 93507574               29-Oct-12 17:36

               Filename: C:\Projects\Arduino\Linduino\Test\CCS\CCS_TEST.lst

               ROM used: 2139 words (26%)
                         Largest free fragment is 2048
               RAM used: 344 (93%) at main() level
                         358 (97%) worst case
               Stack:    2 locations

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... //This program checks that all of the released drivers compile directly in CCS 
....................  
.................... #include <CCS_TEST.h> 
.................... #include <16F877a.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device adc=16 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(clock=20000000) 
*
00F4:  MOVLW  E4
00F5:  MOVWF  04
00F6:  BSF    03.7
00F7:  MOVF   00,W
00F8:  BTFSC  03.2
00F9:  GOTO   107
00FA:  MOVLW  06
00FB:  MOVWF  78
00FC:  CLRF   77
00FD:  DECFSZ 77,F
00FE:  GOTO   0FD
00FF:  DECFSZ 78,F
0100:  GOTO   0FC
0101:  MOVLW  7B
0102:  MOVWF  77
0103:  DECFSZ 77,F
0104:  GOTO   103
0105:  DECFSZ 00,F
0106:  GOTO   0FA
0107:  RETURN
.................... #use I2C(master, sda=PIN_C5, scl=PIN_C3) 
*
0034:  MOVLW  08
0035:  MOVWF  78
0036:  MOVLW  04
0037:  MOVWF  77
0038:  DECFSZ 77,F
0039:  GOTO   038
003A:  BCF    07.3
003B:  BCF    20.3
003C:  MOVF   20,W
003D:  BSF    03.5
003E:  MOVWF  07
003F:  MOVLW  03
0040:  MOVWF  77
0041:  DECFSZ 77,F
0042:  GOTO   041
0043:  BSF    03.6
0044:  RLF    66,F
0045:  BCF    03.5
0046:  BCF    03.6
0047:  BCF    07.5
0048:  BTFSS  03.0
0049:  GOTO   050
004A:  BSF    20.5
004B:  MOVF   20,W
004C:  BSF    03.5
004D:  MOVWF  07
004E:  GOTO   054
004F:  BCF    03.5
0050:  BCF    20.5
0051:  MOVF   20,W
0052:  BSF    03.5
0053:  MOVWF  07
0054:  NOP
0055:  BCF    03.5
0056:  BSF    20.3
0057:  MOVF   20,W
0058:  BSF    03.5
0059:  MOVWF  07
005A:  BCF    03.5
005B:  BTFSS  07.3
005C:  GOTO   05B
005D:  DECFSZ 78,F
005E:  GOTO   036
005F:  MOVLW  04
0060:  MOVWF  77
0061:  DECFSZ 77,F
0062:  GOTO   061
0063:  BCF    07.3
0064:  BCF    20.3
0065:  MOVF   20,W
0066:  BSF    03.5
0067:  MOVWF  07
0068:  NOP
0069:  BCF    03.5
006A:  BSF    20.5
006B:  MOVF   20,W
006C:  BSF    03.5
006D:  MOVWF  07
006E:  MOVLW  03
006F:  MOVWF  77
0070:  DECFSZ 77,F
0071:  GOTO   070
0072:  MOVLW  03
0073:  MOVWF  77
0074:  DECFSZ 77,F
0075:  GOTO   074
0076:  BCF    03.5
0077:  BSF    20.3
0078:  MOVF   20,W
0079:  BSF    03.5
007A:  MOVWF  07
007B:  BCF    03.5
007C:  BTFSS  07.3
007D:  GOTO   07C
007E:  CLRF   78
007F:  MOVLW  03
0080:  MOVWF  77
0081:  DECFSZ 77,F
0082:  GOTO   081
0083:  BTFSC  07.5
0084:  BSF    78.0
0085:  BCF    07.3
0086:  BCF    20.3
0087:  MOVF   20,W
0088:  BSF    03.5
0089:  MOVWF  07
008A:  BCF    03.5
008B:  BCF    07.5
008C:  BCF    20.5
008D:  MOVF   20,W
008E:  BSF    03.5
008F:  MOVWF  07
0090:  BCF    03.5
0091:  RETURN
0092:  MOVLW  08
0093:  BSF    03.5
0094:  BSF    03.6
0095:  MOVWF  66
0096:  MOVF   77,W
0097:  MOVWF  67
0098:  BCF    03.5
0099:  BCF    03.6
009A:  BSF    20.5
009B:  MOVF   20,W
009C:  BSF    03.5
009D:  MOVWF  07
009E:  MOVLW  03
009F:  MOVWF  77
00A0:  DECFSZ 77,F
00A1:  GOTO   0A0
00A2:  BCF    03.5
00A3:  BSF    20.3
00A4:  MOVF   20,W
00A5:  BSF    03.5
00A6:  MOVWF  07
00A7:  BCF    03.5
00A8:  BTFSS  07.3
00A9:  GOTO   0A8
00AA:  BTFSC  07.5
00AB:  BSF    03.0
00AC:  BTFSS  07.5
00AD:  BCF    03.0
00AE:  RLF    78,F
00AF:  MOVLW  04
00B0:  MOVWF  77
00B1:  DECFSZ 77,F
00B2:  GOTO   0B1
00B3:  BCF    20.3
00B4:  MOVF   20,W
00B5:  BSF    03.5
00B6:  MOVWF  07
00B7:  BCF    03.5
00B8:  BCF    07.3
00B9:  BSF    03.5
00BA:  BSF    03.6
00BB:  DECFSZ 66,F
00BC:  GOTO   098
00BD:  BCF    03.5
00BE:  BCF    03.6
00BF:  BSF    20.5
00C0:  MOVF   20,W
00C1:  BSF    03.5
00C2:  MOVWF  07
00C3:  MOVLW  03
00C4:  MOVWF  77
00C5:  DECFSZ 77,F
00C6:  GOTO   0C5
00C7:  BCF    03.5
00C8:  BCF    07.5
00C9:  BSF    03.5
00CA:  BSF    03.6
00CB:  MOVF   67,W
00CC:  BTFSC  03.2
00CD:  GOTO   0D5
00CE:  BCF    03.5
00CF:  BCF    03.6
00D0:  BCF    20.5
00D1:  MOVF   20,W
00D2:  BSF    03.5
00D3:  MOVWF  07
00D4:  BSF    03.6
00D5:  NOP
00D6:  BCF    03.5
00D7:  BCF    03.6
00D8:  BSF    20.3
00D9:  MOVF   20,W
00DA:  BSF    03.5
00DB:  MOVWF  07
00DC:  BCF    03.5
00DD:  BTFSS  07.3
00DE:  GOTO   0DD
00DF:  MOVLW  04
00E0:  MOVWF  77
00E1:  DECFSZ 77,F
00E2:  GOTO   0E1
00E3:  BCF    07.3
00E4:  BCF    20.3
00E5:  MOVF   20,W
00E6:  BSF    03.5
00E7:  MOVWF  07
00E8:  MOVLW  03
00E9:  MOVWF  77
00EA:  DECFSZ 77,F
00EB:  GOTO   0EA
00EC:  BCF    03.5
00ED:  BCF    07.5
00EE:  BCF    20.5
00EF:  MOVF   20,W
00F0:  BSF    03.5
00F1:  MOVWF  07
00F2:  BCF    03.5
00F3:  RETURN
....................  
.................... #type int=16, long=32 
....................  
.................... #define MISO PIN_C4 
.................... #define MOSI PIN_C5 
.................... #define CS   PIN_B5 
.................... #define SCK  PIN_C3 
.................... #define SCL  PIN_C3 
.................... #define SDAO PIN_C5 
.................... #define SDAI PIN_C4 
....................  
.................... #include  <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC1867\LTC1867.h" 
.................... /* 
.................... LTC1867 
....................  
.................... 16-bit 8-channel 200ksps ADC 
....................  
.................... SPI DATA FORMAT (MSB First): 
....................  
....................             Byte #1                           Byte #2  
.................... Data Out :  D15 D14 D13 D12 D11 D10 D9  D8    D7  D6  D5  D4  D3  D2  D1  D0 
.................... Data In  :  SD  OS  S1  S0  COM UNI SLP X     X   X   X   X   X   X   X   X 
....................  
.................... SD   : Single/Differential Bit 
.................... OS   : ODD/Sign Bit 
.................... Sx   : Address Select Bit 
.................... COM  : CH7/COM Configuration Bit 
.................... UNI  : Unipolar/Bipolar Bit 
.................... SLP  : Sleep Mode Bit 
.................... Dx   : Data Bits 
.................... X    : Don't care  
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 719 $ 
.................... $Date: 2012-10-26 14:22:35 -0700 (Fri, 26 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
.................... */ 
....................  
.................... #ifndef LTC1867_h 
.................... #define LTC1867_h 
....................  
.................... //Define the CS pin 
.................... #ifndef LTC1867_CS 
....................   #define LTC1867_CS CS 
.................... #endif 
....................  
.................... //Single-Ended Channel Configuration When CH7/COM Pin Is used As CH7 
.................... #define LTC1867_CH0             0x84 
.................... #define LTC1867_CH1             0xC4 
.................... #define LTC1867_CH2             0x94 
.................... #define LTC1867_CH3             0xD4 
.................... #define LTC1867_CH4             0xA4 
.................... #define LTC1867_CH5             0xE4 
.................... #define LTC1867_CH6             0xB4 
.................... #define LTC1867_CH7             0xF4 
....................  
.................... //Differential Channel Configuration When CH7/COM Pin Is Used As CH7 
.................... #define LTC1867_P0_N1           0x00 
.................... #define LTC1867_P1_N0           0x40 
....................  
.................... #define LTC1867_P2_N3           0x10 
.................... #define LTC1867_P3_N2           0x50 
....................  
.................... #define LTC1867_P4_N5           0x20 
.................... #define LTC1867_P5_N4           0x60 
....................  
.................... #define LTC1867_P6_N7           0x30 
.................... #define LTC1867_P7_N6           0x70 
....................  
.................... //Channel Configuration When CH7/COM Pin Is Used As Common 
.................... #define LTC1867_CH0_7COM        0x8C 
.................... #define LTC1867_CH1_7COM        0xCC 
.................... #define LTC1867_CH2_7COM        0x9C 
.................... #define LTC1867_CH3_7COM        0xDC 
.................... #define LTC1867_CH4_7COM        0xAC 
.................... #define LTC1867_CH5_7COM        0xEC 
.................... #define LTC1867_CH6_7COM        0xBC 
....................  
.................... //Sleep Mode Command 
.................... #define LTC1867_SLEEP_MODE      0x02 
.................... #define LTC1867_EXIT_SLEEP_MODE 0x00 
.................... #define LTC1867_UNIPOLAR_MODE   0x04  // bitwise or with channel commands to enter in unipolar mode 
....................  
.................... /* 
....................   Example command 
....................   adc_command = LTC1867_P0_N1;                             // Differential Bipolar Mode with CH0 as positive and CH1 as negative.  
....................   adc_command = LTC1867_P0_N1 | LTC1867_UNIPOLAR_MODE;     // Differential Unipolar Mode with CH0 as positive and CH1 as negative.  
....................  */ 
....................   
.................... float LTC1867_lsb = 6.25009537E-5; 
.................... float LTC1867_offset_unipolar_code=0; 
.................... float LTC1867_offset_bipolar_code=0; 
....................  
.................... int LTC1867_read(unsigned char adc_command) 
.................... { 
....................     union {unsigned char b[2];int w;} data;  // LTC1867 data 
....................     output_low(LTC1867_CS);                  // Pull CS low  
*
0004:  BSF    03.5
0005:  BCF    06.5
0006:  BCF    03.5
0007:  BCF    06.5
....................     data.b[1]=spi_read(adc_command);         // Read first byte and send adc command 
0008:  MOVF   13,W
0009:  BSF    03.5
000A:  BSF    03.6
000B:  MOVF   5A,W
000C:  BCF    03.5
000D:  BCF    03.6
000E:  MOVWF  13
000F:  BSF    03.5
0010:  RRF    14,W
0011:  BTFSS  03.0
0012:  GOTO   010
0013:  BCF    03.5
0014:  MOVF   13,W
0015:  BSF    03.5
0016:  BSF    03.6
0017:  MOVWF  5C
....................     data.b[0]=spi_read(0x00);                // Read last byte 
0018:  BCF    03.5
0019:  BCF    03.6
001A:  MOVF   13,W
001B:  CLRF   13
001C:  BSF    03.5
001D:  RRF    14,W
001E:  BTFSS  03.0
001F:  GOTO   01D
0020:  BCF    03.5
0021:  MOVF   13,W
0022:  BSF    03.5
0023:  BSF    03.6
0024:  MOVWF  5B
....................     output_high(LTC1867_CS);                 // Pull CS high 
0025:  BCF    03.6
0026:  BCF    06.5
0027:  BCF    03.5
0028:  BSF    06.5
....................     return(data.w); 
0029:  BSF    03.5
002A:  BSF    03.6
002B:  MOVF   5B,W
002C:  MOVWF  78
002D:  MOVF   5C,W
002E:  MOVWF  79
.................... } 
002F:  BCF    03.6
0030:  BCF    03.5
0031:  BSF    0A.3
0032:  BCF    0A.4
0033:  GOTO   0E1 (RETURN)
....................  
.................... float LTC1867_unipolar_voltage(unsigned int adc_code) 
.................... //Calculates the LTC1867 input binary data to unipolar voltage. 
.................... {  
....................     float adc_voltage; 
....................     adc_voltage=((float)adc_code-LTC1867_offset_unipolar_code)*LTC1867_lsb; 
....................     return(adc_voltage);    
.................... } 
.................... float LTC1867_bipolar_voltage(int adc_code) 
.................... //Calculates the LTC1867 input two's compliment data to bipolar voltage 
.................... { 
....................     float adc_voltage; 
....................     adc_voltage=((float)adc_code-LTC1867_offset_bipolar_code)*LTC1867_lsb; 
....................     return(adc_voltage); 
.................... } 
....................  
.................... void LTC1867_cal_voltage(unsigned int zero_unipolar_code,unsigned int zero_bipolar_code, unsigned int fs_code,float fs_voltage) 
.................... //Calibrate the lsb 
.................... {  
....................     LTC1867_offset_bipolar_code = (float)zero_bipolar_code; 
....................     LTC1867_offset_unipolar_code = (float)zero_unipolar_code; 
....................     LTC1867_lsb = fs_voltage/((float)fs_code-LTC1867_offset_unipolar_code); 
.................... } 
.................... #endif 
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC2309\LTC2309.h" 
.................... /* 
.................... LTC2309 
.................... 12-bit, 8-channel SAR ADC 
....................  
.................... I2C DATA FORMAT (MSB First): 
....................    
....................        Byte #1                                    Byte #2                       Byte #3                             Byte #4 
....................                                                                          MSB                                 LSB 
.................... START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 W SACK  C3 C2 C1 C0 A3 A2 A1 A0 SACK  D11 D10 D9  D8  D7  D6  D5 D4 SACK  D3 D2 D1 D0 X  X  X  X  SACK  STOP 
....................  
.................... SD   : Single/Differential Bit 
.................... OS   : ODD/Sign Bit 
.................... Sx   : Address Select Bit 
.................... COM  : CH7/COM Configuration Bit 
.................... UNI  : Unipolar/Bipolar Bit 
.................... SLP  : Sleep Mode Bit 
.................... Dx   : Data Bits 
.................... X    : Don't care  
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 719 $ 
.................... $Date: 2012-10-26 14:22:35 -0700 (Fri, 26 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
.................... */ 
....................  
.................... #ifndef LTC2309_h 
.................... #define LTC2309_h 
....................  
.................... // Address Choices: 
.................... // To choose an address, comment out all options except the  
.................... // configuration on the demo board. 
....................  
....................                                       //  Address assignment 
.................... //LTC2309 I2C Address                 //  AD1       AD0 
.................... #define LTC2309_I2C_ADDRESS 0x10      //  LOW       LOW 
.................... //#define LTC2309_I2C_ADDRESS 0x12    //  LOW       Float 
.................... //#define LTC2309_I2C_ADDRESS 0x14    //  LOW       HIGH 
.................... //#define LTC2309_I2C_ADDRESS 0x16    //  Float     HIGH 
.................... //#define LTC2309_I2C_ADDRESS 0x30    //  Float     Float 
.................... //#define LTC2309_I2C_ADDRESS 0x32    //  Float     LOW 
.................... //#define LTC2309_I2C_ADDRESS 0x34    //  HIGH      LOW 
.................... //#define LTC2309_I2C_ADDRESS 0x36    //  HIGH      Float 
.................... //#define LTC2309_I2C_ADDRESS 0x28    //  High      HIGH 
....................  
....................  
.................... //Single-Ended Channel Configuration 
.................... #define LTC2309_CH0                0x88 
.................... #define LTC2309_CH1                0xC8 
.................... #define LTC2309_CH2                0x98 
.................... #define LTC2309_CH3                0xD8 
.................... #define LTC2309_CH4                0xA8 
.................... #define LTC2309_CH5                0xE8 
.................... #define LTC2309_CH6                0xB8 
.................... #define LTC2309_CH7                0xF8 
....................  
.................... //Differential Channel Configuration 
.................... #define LTC2309_P0_N1              0x00 
.................... #define LTC2309_P1_N0              0x40 
....................  
.................... #define LTC2309_P2_N3              0x10 
.................... #define LTC2309_P3_N2              0x50 
....................  
.................... #define LTC2309_P4_N5              0x20 
.................... #define LTC2309_P5_N4              0x60 
....................  
.................... #define LTC2309_P6_N7              0x30 
.................... #define LTC2309_P7_N6              0x70 
....................  
....................  
.................... //Command 
.................... #define LTC2309_SLEEP_MODE         0x04 
.................... #define LTC2309_EXIT_SLEEP_MODE    0x00 
.................... #define LTC2309_UNIPOLAR_MODE      0x08  
....................  
....................  
.................... // Commands 
.................... // Construct a channel / uni/bipolar int by bitwise ORing one choice from the channel configuration 
.................... // and one choice from the command.  
....................  
.................... // Example - read channel 3 single-ended  
.................... // adc_command = LTC2309_CH3 | LTC2309_UNIPOLAR_MODE; 
....................  
.................... // Example - read channels 5 and 4 with 4 as positive polarity and in bipolar mode. 
.................... // adc_command = LTC2309_P4_N5; 
....................  
.................... //Calibration Variables 
.................... float LTC2309_lsb = 1.0002442E-03; 
.................... float LTC2309_offset_code=0; 
....................  
.................... unsigned char LTC2309_read(unsigned char i2c_address, unsigned char adc_command, int& code) 
.................... //Reads 12 bits 
.................... { 
*
08EC:  CLRF   5C
....................     unsigned char ack = 0; 
....................     union {unsigned char b[2];long w;} data;    // combines bytes 
....................     i2c_start();                                // write an I2C start bit 
08ED:  BCF    03.5
08EE:  BCF    03.6
08EF:  BSF    20.5
08F0:  MOVF   20,W
08F1:  BSF    03.5
08F2:  MOVWF  07
08F3:  MOVLW  04
08F4:  MOVWF  77
08F5:  DECFSZ 77,F
08F6:  GOTO   0F5
08F7:  BCF    03.5
08F8:  BSF    20.3
08F9:  MOVF   20,W
08FA:  BSF    03.5
08FB:  MOVWF  07
08FC:  MOVLW  03
08FD:  MOVWF  77
08FE:  DECFSZ 77,F
08FF:  GOTO   0FE
0900:  BCF    03.5
0901:  BCF    07.5
0902:  BCF    20.5
0903:  MOVF   20,W
0904:  BSF    03.5
0905:  MOVWF  07
0906:  MOVLW  04
0907:  MOVWF  77
0908:  DECFSZ 77,F
0909:  GOTO   108
090A:  BCF    03.5
090B:  BCF    07.3
090C:  BCF    20.3
090D:  MOVF   20,W
090E:  BSF    03.5
090F:  MOVWF  07
....................     ack = i2c_write(i2c_address & 0xFE);        // write the I2C 8 bit address and !W bit in the LSB position 
0910:  BSF    03.6
0911:  MOVF   5A,W
0912:  ANDLW  FE
0913:  MOVWF  61
0914:  MOVWF  66
0915:  BCF    0A.3
0916:  BCF    03.5
0917:  BCF    03.6
0918:  CALL   034
0919:  BSF    0A.3
091A:  MOVF   78,W
091B:  BSF    03.5
091C:  BSF    03.6
091D:  MOVWF  5C
....................     if(!ack) 
091E:  MOVF   5C,F
091F:  BTFSS  03.2
0920:  GOTO   177
....................     { 
....................         ack = i2c_write(adc_command);           // write the command byte 
0921:  MOVF   5B,W
0922:  MOVWF  66
0923:  BCF    0A.3
0924:  BCF    03.5
0925:  BCF    03.6
0926:  CALL   034
0927:  BSF    0A.3
0928:  MOVF   78,W
0929:  BSF    03.5
092A:  BSF    03.6
092B:  MOVWF  5C
....................         i2c_start(); 
092C:  BCF    03.5
092D:  BCF    03.6
092E:  BSF    20.5
092F:  MOVF   20,W
0930:  BSF    03.5
0931:  MOVWF  07
0932:  MOVLW  04
0933:  MOVWF  77
0934:  DECFSZ 77,F
0935:  GOTO   134
0936:  BCF    03.5
0937:  BSF    20.3
0938:  MOVF   20,W
0939:  BSF    03.5
093A:  MOVWF  07
093B:  MOVLW  03
093C:  MOVWF  77
093D:  DECFSZ 77,F
093E:  GOTO   13D
093F:  BCF    03.5
0940:  BTFSS  07.3
0941:  GOTO   140
0942:  BCF    07.5
0943:  BCF    20.5
0944:  MOVF   20,W
0945:  BSF    03.5
0946:  MOVWF  07
0947:  MOVLW  04
0948:  MOVWF  77
0949:  DECFSZ 77,F
094A:  GOTO   149
094B:  BCF    03.5
094C:  BCF    07.3
094D:  BCF    20.3
094E:  MOVF   20,W
094F:  BSF    03.5
0950:  MOVWF  07
....................         ack=i2c_write(i2c_address | 0x01);      // write the I2C 8 bit address and !R bit in the LSB position 
0951:  BSF    03.6
0952:  MOVF   5A,W
0953:  IORLW  01
0954:  MOVWF  61
0955:  MOVWF  66
0956:  BCF    0A.3
0957:  BCF    03.5
0958:  BCF    03.6
0959:  CALL   034
095A:  BSF    0A.3
095B:  MOVF   78,W
095C:  BSF    03.5
095D:  BSF    03.6
095E:  MOVWF  5C
....................         if(!ack) 
095F:  MOVF   5C,F
0960:  BTFSS  03.2
0961:  GOTO   177
....................         { 
....................             data.b[1]=i2c_read(0);              // reads MSB byte with ACK 
0962:  CLRF   77
0963:  BCF    0A.3
0964:  BCF    03.5
0965:  BCF    03.6
0966:  CALL   092
0967:  BSF    0A.3
0968:  MOVF   78,W
0969:  BSF    03.5
096A:  BSF    03.6
096B:  MOVWF  5E
....................             data.b[0]=i2c_read(1);              // reads LSB byte with Nack 
096C:  MOVLW  01
096D:  MOVWF  77
096E:  BCF    0A.3
096F:  BCF    03.5
0970:  BCF    03.6
0971:  CALL   092
0972:  BSF    0A.3
0973:  MOVF   78,W
0974:  BSF    03.5
0975:  BSF    03.6
0976:  MOVWF  5D
....................         } 
....................     } 
....................     i2c_stop();                                 // write an I2C stop bit 
0977:  BCF    03.5
0978:  BCF    03.6
0979:  BCF    20.5
097A:  MOVF   20,W
097B:  BSF    03.5
097C:  MOVWF  07
097D:  NOP
097E:  BCF    03.5
097F:  BSF    20.3
0980:  MOVF   20,W
0981:  BSF    03.5
0982:  MOVWF  07
0983:  BCF    03.5
0984:  BTFSS  07.3
0985:  GOTO   184
0986:  MOVLW  04
0987:  MOVWF  77
0988:  DECFSZ 77,F
0989:  GOTO   188
098A:  GOTO   18B
098B:  NOP
098C:  BSF    20.5
098D:  MOVF   20,W
098E:  BSF    03.5
098F:  MOVWF  07
0990:  MOVLW  04
0991:  MOVWF  77
0992:  DECFSZ 77,F
0993:  GOTO   192
....................     data.w >>= 4;                               // shifts data 4 bits to the right 
0994:  BSF    03.6
0995:  RRF    60,F
0996:  RRF    5F,F
0997:  RRF    5E,F
0998:  RRF    5D,F
0999:  RRF    60,F
099A:  RRF    5F,F
099B:  RRF    5E,F
099C:  RRF    5D,F
099D:  RRF    60,F
099E:  RRF    5F,F
099F:  RRF    5E,F
09A0:  RRF    5D,F
09A1:  RRF    60,F
09A2:  RRF    5F,F
09A3:  RRF    5E,F
09A4:  RRF    5D,F
09A5:  MOVLW  0F
09A6:  ANDWF  60,F
....................     code = data.w;                               
09A7:  MOVF   5E,W
09A8:  MOVWF  41
09A9:  MOVF   5D,W
09AA:  MOVWF  40
....................     return(ack); 
09AB:  MOVF   5C,W
09AC:  MOVWF  78
.................... } 
....................  
.................... float LTC2309_unipolar_voltage(long adc_code) 
.................... //Calculates the LTC2309 input unipolar voltage. 
.................... { 
....................     float adc_voltage; 
....................     adc_voltage=((float)adc_code-LTC2309_offset_code)*LTC2309_lsb; 
....................     return(adc_voltage);    
.................... } 
.................... float LTC2309_bipolar_voltage(long adc_code) 
.................... //Calculates the LTC2309 input bipolar voltage 
.................... { 
....................     float adc_voltage, sign = 1.0; 
....................     if(adc_code>>11) 
....................     { 
....................         adc_code = (adc_code ^ 0xFFF )+1;       // converts two's complement 
....................         sign = -1; 
....................     } 
....................     adc_voltage=((float)adc_code-LTC2309_offset_code)*LTC2309_lsb*sign; 
....................     return(adc_voltage); 
.................... } 
....................  
.................... void LTC2309_cal_voltage(long zero_code,long fs_code,float fs_voltage) 
.................... //Calibrate the lsb 
.................... {  
....................     LTC2309_offset_code=(float)zero_code; 
....................     LTC2309_lsb=fs_voltage/((float)fs_code-LTC2309_offset_code); 
.................... } 
.................... #endif 
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC2418\LTC2418.h" 
.................... /* 
.................... LTC2418 
.................... 24-bit No Latency Delta Sigma 16-channel ADC 
....................  
.................... SPI DATA FORMAT (MSB First): 
....................    
....................             Byte #1                            Byte #2                           Byte #3                    Byte #4 
....................                                                                                                                                    
.................... Data Out :  !EOC DMY SIG D22 D21 D20 D19 D18   D17 D16 D15 D14 D13 D12 D11 D10   D9 D8 D7 D6 D5 D4  D3 D2   D1 D0 SGL OS S2 S1 S0 PAR  
.................... Data In  :  1    0   EN  SGL OS  S2  S1  S0    X   X   X   X   X   X   X   X     X  X  X  X  X  X   X  X    X  X  X   X  X  X  X  X 
....................    
.................... !EOC : End of Conversion Bit (Active Low) 
.................... DMY  : Dummy Bit (Always 0) 
.................... SIG  : Sign Bit (1-data positive, 0-data negative) 
.................... Dx   : Data Bits 
.................... EN   : Enable Bit (0-keep previous mode, 1-change mode) 
.................... SGL  : Enable Single-ended bit (0-differential 1-single-ended 
.................... OS   : ODD/Sign Bit 
.................... Sx   : Address Select Bit 
.................... 0SRX : Over Sampeling Rate Bits 
.................... PAR  : Parity Bit  
....................  
.................... Command Byte 
.................... 1    0    EN   SGL  OS   S2   S1   S0   Comments 
.................... 1    0    0    X    X    X    X    X    Keep Previous Mode     
.................... 1    0    1    0    X    X    X    X    Differential Mode  
.................... 1    0    1    1    X    X    X    X    Single-ended Mode 
....................  
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 699 $ 
.................... $Date: 2012-10-12 13:52:06 -0700 (Fri, 12 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
.................... */ 
....................  
.................... #ifndef LTC2418_h 
.................... #define LTC2418_h 
....................  
.................... //Define the CS pin 
.................... #ifndef LTC2418_CS 
....................   #define LTC2418_CS CS 
.................... #endif 
....................  
.................... //MISO timeout in ms 
.................... #define MISO_timeout 1000 
....................  
.................... //Commands 
.................... #define LTC2418_KEEP_PREVIOUS_MODE              0x80 
.................... #define LTC2418_KEEP_PREVIOUS_SPEED_RESOLUTION  0x00 
....................  
.................... //Single-Ended Channels Configuration 
.................... #define LTC2418_CH0            0xB0 
.................... #define LTC2418_CH1            0xB8 
.................... #define LTC2418_CH2            0xB1 
.................... #define LTC2418_CH3            0xB9 
.................... #define LTC2418_CH4            0xB2 
.................... #define LTC2418_CH5            0xBA 
.................... #define LTC2418_CH6            0xB3 
.................... #define LTC2418_CH7            0xBB 
.................... #define LTC2418_CH8            0xB4 
.................... #define LTC2418_CH9            0xBC 
.................... #define LTC2418_CH10           0xB5 
.................... #define LTC2418_CH11           0xBD 
.................... #define LTC2418_CH12           0xB6 
.................... #define LTC2418_CH13           0xBE 
.................... #define LTC2418_CH14           0xB7 
.................... #define LTC2418_CH15           0xBF 
....................  
.................... //Differential Channel Configuration 
.................... #define LTC2418_P0_N1          0xA0 
.................... #define LTC2418_P1_N0          0xA8 
....................  
.................... #define LTC2418_P2_N3          0xA1 
.................... #define LTC2418_P3_N2          0xA9 
....................  
.................... #define LTC2418_P4_N5          0xA2 
.................... #define LTC2418_P5_N4          0xAA 
....................  
.................... #define LTC2418_P6_N7          0xA3 
.................... #define LTC2418_P7_N6          0xAB 
....................  
.................... #define LTC2418_P8_N9          0xA4 
.................... #define LTC2418_P9_N8          0xAC 
....................  
.................... #define LTC2418_P10_N11        0xA5 
.................... #define LTC2418_P11_N10        0xAD 
....................  
.................... #define LTC2418_P12_N13        0xA6 
.................... #define LTC2418_P13_N12        0xAE 
....................  
.................... #define LTC2418_P14_N15        0xA7 
.................... #define LTC2418_P15_N14        0xAF 
....................  
.................... float LTC2418_lsb = 5.9604652E-7; 
.................... float LTC2418_offset_code = 0; 
....................  
.................... long LTC2418_read(unsigned char adc_command) 
.................... { 
*
0108:  BSF    03.5
0109:  BSF    03.6
010A:  CLRF   5C
010B:  CLRF   5B
....................     unsigned int timer_count = 0;            // Timer count for MISO 
....................     union {unsigned char b[4];long w;} data; // LTC2418 data 
....................     output_low(LTC2418_CS);                  // Pull CS low  
010C:  BCF    03.6
010D:  BCF    06.5
010E:  BCF    03.5
010F:  BCF    06.5
....................     while(1)                                 // wait for SDO (MISO) to go low  
....................     { 
....................         if(input(MISO)==0) break;            // If SDO is low, break loop 
0110:  BSF    20.4
0111:  MOVF   20,W
0112:  BSF    03.5
0113:  MOVWF  07
0114:  BCF    03.5
0115:  BTFSS  07.4
0116:  GOTO   13C
....................         if(timer_count++>MISO_timeout)       // If timeout, return 0 
0117:  BSF    03.5
0118:  BSF    03.6
0119:  MOVF   5C,W
011A:  MOVWF  7A
011B:  MOVF   5B,W
011C:  INCF   5B,F
011D:  BTFSC  03.2
011E:  INCF   5C,F
011F:  MOVWF  61
0120:  MOVF   7A,W
0121:  MOVWF  62
0122:  SUBLW  02
0123:  BTFSC  03.0
0124:  GOTO   132
0125:  XORLW  FF
0126:  BTFSS  03.2
0127:  GOTO   12C
0128:  MOVF   61,W
0129:  SUBLW  E8
012A:  BTFSC  03.0
012B:  GOTO   132
....................         return(0); else delay_ms(1); 
012C:  CLRF   77
012D:  CLRF   78
012E:  CLRF   79
012F:  CLRF   7A
0130:  GOTO   181
0131:  GOTO   139
0132:  MOVLW  01
0133:  MOVWF  64
0134:  BCF    03.5
0135:  BCF    03.6
0136:  CALL   0F4
0137:  BSF    03.5
0138:  BSF    03.6
....................     } 
0139:  BCF    03.5
013A:  BCF    03.6
013B:  GOTO   110
....................     data.b[3]=spi_read(adc_command);         // Read first byte and send first adc command 
013C:  MOVF   13,W
013D:  BSF    03.5
013E:  BSF    03.6
013F:  MOVF   5A,W
0140:  BCF    03.5
0141:  BCF    03.6
0142:  MOVWF  13
0143:  BSF    03.5
0144:  RRF    14,W
0145:  BTFSS  03.0
0146:  GOTO   144
0147:  BCF    03.5
0148:  MOVF   13,W
0149:  BSF    03.5
014A:  BSF    03.6
014B:  MOVWF  60
....................     data.b[2]=spi_read(0x00);                // Read second byte and send last adc command 
014C:  BCF    03.5
014D:  BCF    03.6
014E:  MOVF   13,W
014F:  CLRF   13
0150:  BSF    03.5
0151:  RRF    14,W
0152:  BTFSS  03.0
0153:  GOTO   151
0154:  BCF    03.5
0155:  MOVF   13,W
0156:  BSF    03.5
0157:  BSF    03.6
0158:  MOVWF  5F
....................     data.b[1]=spi_read(0x00);                // Read third byte 
0159:  BCF    03.5
015A:  BCF    03.6
015B:  MOVF   13,W
015C:  CLRF   13
015D:  BSF    03.5
015E:  RRF    14,W
015F:  BTFSS  03.0
0160:  GOTO   15E
0161:  BCF    03.5
0162:  MOVF   13,W
0163:  BSF    03.5
0164:  BSF    03.6
0165:  MOVWF  5E
....................     data.b[0]=spi_read(0x00);                // Read last byte 
0166:  BCF    03.5
0167:  BCF    03.6
0168:  MOVF   13,W
0169:  CLRF   13
016A:  BSF    03.5
016B:  RRF    14,W
016C:  BTFSS  03.0
016D:  GOTO   16B
016E:  BCF    03.5
016F:  MOVF   13,W
0170:  BSF    03.5
0171:  BSF    03.6
0172:  MOVWF  5D
....................     output_high(LTC2418_CS);                 // Pull CS high 
0173:  BCF    03.6
0174:  BCF    06.5
0175:  BCF    03.5
0176:  BSF    06.5
....................     return(data.w); 
0177:  BSF    03.5
0178:  BSF    03.6
0179:  MOVF   5D,W
017A:  MOVWF  77
017B:  MOVF   5E,W
017C:  MOVWF  78
017D:  MOVF   5F,W
017E:  MOVWF  79
017F:  MOVF   60,W
0180:  MOVWF  7A
.................... } 
0181:  BCF    03.6
0182:  BCF    03.5
0183:  BSF    0A.3
0184:  BCF    0A.4
0185:  GOTO   1B5 (RETURN)
....................  
.................... float LTC2418_voltage(long adc_code) 
.................... //Calculates the LTC2418 input bipolar voltage 
.................... { 
....................     float adc_voltage; 
....................     adc_code = adc_code>>6; 
....................     adc_code -= 8388608;                     // Converts offset binary to binary 
....................     adc_voltage=((float)adc_code-LTC2418_offset_code)*LTC2418_lsb; 
....................     return(adc_voltage); 
.................... } 
....................  
.................... void LTC2418_cal_voltage(long zero_code,long fs_code,float fs_voltage) 
.................... //Calibrate the lsb 
.................... {  
....................     zero_code = zero_code >> 6; 
....................     zero_code -= 8388608; 
....................     fs_code = fs_code >> 6; 
....................     fs_code -= 8388608; 
....................     LTC2418_offset_code=(float)zero_code; 
....................     LTC2418_lsb=fs_voltage/((float)fs_code-LTC2418_offset_code); 
.................... } 
.................... #endif 
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC2449\LTC2449.h" 
.................... /* 
.................... LTC2449 
.................... 24-bit High Speed 16-channel ADC 
....................  
.................... SPI DATA FORMAT (MSB First): 
....................    
....................             Byte #1                            Byte #2                           Byte #3                        Byte #4 
....................                                                                                                                                    
.................... Data Out :  !EOC DMY SIG D28 D27 D26 D25 D24   D23  D22  D21  D20  D19 D18 D17 D16   D15 D14 D13 D12 D11 D10 D9 D8  D7 D6 D5 D4 *D3 *D2 *D1 *D0  
.................... Data In  :  1    0   EN  SGL OS  S2  S1  S0    OSR3 OSR2 OSR1 OSR1 SPD X   X   X     X   X   X   X   X   X   X  X   X  X  X  X   X  X   X   X 
....................    
.................... !EOC : End of Conversion Bit (Active Low) 
.................... DMY  : Dummy Bit (Always 0) 
.................... SIG  : Sign Bit (1-data positive, 0-data negative) 
.................... Dx   : Data Bits 
.................... *Dx  : Data Bits Below lsb 
.................... EN   : Enable Bit (0-keep previous mode, 1-change mode) 
.................... SGL  : Enable Single-ended bit (0-differential 1-single-ended 
.................... OS   : ODD/Sign Bit 
.................... Sx   : Address Select Bit 
.................... 0SRX : Over Sampeling Rate Bits 
.................... SPD  : Double Output Rate Select Bit (0-Normal rate, auto-calibration on, 2x rate, auto_calibration off) 
....................  
....................  
....................  
.................... Command Byte #1 
.................... 1    0    EN   SGL  OS   S2   S1   S0   Comments 
.................... 1    0    0    X    X    X    X    X    Keep Previous Mode     
.................... 1    0    1    0    X    X    X    X    Differential Mode  
.................... 1    0    1    1    X    X    X    X    Single-ended Mode 
....................  
....................   
....................                          |  Coversion Rate    |  RMS  | ENOB | OSR  | Latency 
.................... Command Byte #2          |Internal | External | Noise |      |      | 
....................                          |  9MHz   | 10.24MHz |       |      |      | 
.................... OSR3 OSR2 OSR1 OSR1 SPD  | Clock   |  Clock   |       |      |      | 
.................... 0    0    0    0    0      Keep Previous Speed/Resolution 
.................... 0    0    0    1    0      3.52kHz   4kHz       23uV    17     64     none 
.................... 0    0    1    0    0      1.76kHz   2kHz       3.5uV   20.1   128    none 
.................... 0    0    1    1    0      880Hz     1kHz       2uV     21.3   256    none 
.................... 0    1    0    0    0      440Hz     500Hz      1.4uV   21.8   512    none 
.................... 0    1    0    1    0      220Hz     250Hz      1uV     22.4   1024   none 
.................... 0    1    1    0    0      110Hz     125Hz      750nV   22.9   2048   none 
.................... 0    1    1    1    0      55Hz      62.5Hz     510nV   23.4   4096   none 
.................... 1    0    0    0    0      27.5Hz    31.25Hz    375nV   24     8192   none 
.................... 1    0    0    1    0      13.75Hz   15.625Hz   250nV   24.4   16384  none 
.................... 1    1    1    1    0      6.87kHz   7.8125Hz   200nV   24.6   32768  none 
.................... 0    0    0    0    1      Keep Previous Speed/Resolution 
.................... OSR3 OSR2 OSR1 OSR1 1      2X Mode  *all clock speeds double     
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 699 $ 
.................... $Date: 2012-10-12 13:52:06 -0700 (Fri, 12 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
.................... */ 
....................  
.................... #ifndef LTC2449_h 
.................... #define LTC2449_h 
....................  
.................... //Define the CS pin 
.................... #ifndef LTC2449_CS 
....................   #define LTC2449_CS CS 
.................... #endif 
....................  
.................... //MISO timeout in ms 
.................... #define MISO_timeout 1000 
....................  
.................... // Commands 
.................... // Construct a channel / resolution control word by bitwise ORing one choice from the channel configuration 
.................... // and one choice from the Oversample ratio configuration. You can also enable 2Xmode, which will increase 
.................... // sample rate by a facor of 2 but introduce one cycle of latency. 
....................  
.................... // Example - read channel 3 single-ended at OSR2048, with 2X mode enabled. 
.................... // adc_command = (LTC2449_CH3 | LTC2449_OSR_2048) | LTC2449_SPEED_2X; 
....................  
.................... #define LTC2449_KEEP_PREVIOUS_MODE              0x8000       
.................... #define LTC2449_KEEP_PREVIOUS_SPEED_RESOLUTION  0x0000 
.................... #define LTC2449_SPEED_2X                        0x0008 
....................  
.................... //Single-Ended Channels Configuration 
.................... #define LTC2449_CH0            0xB000 
.................... #define LTC2449_CH1            0xB800 
.................... #define LTC2449_CH2            0xB100 
.................... #define LTC2449_CH3            0xB900 
.................... #define LTC2449_CH4            0xB200 
.................... #define LTC2449_CH5            0xBA00 
.................... #define LTC2449_CH6            0xB300 
.................... #define LTC2449_CH7            0xBB00 
.................... #define LTC2449_CH8            0xB400 
.................... #define LTC2449_CH9            0xBC00 
.................... #define LTC2449_CH10           0xB500 
.................... #define LTC2449_CH11           0xBD00 
.................... #define LTC2449_CH12           0xB600 
.................... #define LTC2449_CH13           0xBE00 
.................... #define LTC2449_CH14           0xB700 
.................... #define LTC2449_CH15           0xBF00 
....................  
.................... //Differential Channel Configuration 
.................... #define LTC2449_P0_N1          0xA000 
.................... #define LTC2449_P1_N0          0xA800 
....................  
.................... #define LTC2449_P2_N3          0xA100 
.................... #define LTC2449_P3_N2          0xA900 
....................  
.................... #define LTC2449_P4_N5          0xA200 
.................... #define LTC2449_P5_N4          0xAA00 
....................  
.................... #define LTC2449_P6_N7          0xA300 
.................... #define LTC2449_P7_N6          0xAB00 
....................  
.................... #define LTC2449_P8_N9          0xA400 
.................... #define LTC2449_P9_N8          0xAC00 
....................  
.................... #define LTC2449_P10_N11        0xA500 
.................... #define LTC2449_P11_N10        0xAD00 
....................  
.................... #define LTC2449_P12_N13        0xA600 
.................... #define LTC2449_P13_N12        0xAE00 
....................  
.................... #define LTC2449_P14_N15        0xA700 
.................... #define LTC2449_P15_N14        0xAF00 
....................  
.................... //Oversample Ratio (OSR) Commands 
.................... #define LTC2449_OSR_64         0xA010 
.................... #define LTC2449_OSR_128        0xA020 
.................... #define LTC2449_OSR_256        0xA030 
.................... #define LTC2449_OSR_512        0xA040 
.................... #define LTC2449_OSR_1024       0xA050 
.................... #define LTC2449_OSR_2048       0xA060 
.................... #define LTC2449_OSR_4096       0xA070 
.................... #define LTC2449_OSR_8192       0xA080 
.................... #define LTC2449_OSR_16384      0xA090 
.................... #define LTC2449_OSR_32768      0xA0F0 
....................  
.................... float LTC2449_lsb = 9.3132258E-9; 
.................... float LTC2449_offset_code=0; 
....................  
.................... long LTC2449_read(int adc_command) 
.................... { 
0186:  BSF    03.5
0187:  BSF    03.6
0188:  CLRF   5D
0189:  CLRF   5C
....................     unsigned int timer_count = 0;            // Timer count for MISO 
....................     union {unsigned char b[4];long w;} data; // LTC2449 data 
....................     union {unsigned char b[2];int w;} command; 
....................     command.w = adc_command; 
018A:  MOVF   5B,W
018B:  MOVWF  63
018C:  MOVF   5A,W
018D:  MOVWF  62
....................     output_low(LTC2449_CS);                  // Pull CS low  
018E:  BCF    03.6
018F:  BCF    06.5
0190:  BCF    03.5
0191:  BCF    06.5
....................     while(1)                                 // wait for SDO (MISO) to go low  
....................     { 
....................         if(input(MISO)==0) break;            // If SDO is low, break loop 
0192:  BSF    20.4
0193:  MOVF   20,W
0194:  BSF    03.5
0195:  MOVWF  07
0196:  BCF    03.5
0197:  BTFSS  07.4
0198:  GOTO   1BE
....................         if(timer_count++>MISO_timeout)       // If timeout, return 0 
0199:  BSF    03.5
019A:  BSF    03.6
019B:  MOVF   5D,W
019C:  MOVWF  7A
019D:  MOVF   5C,W
019E:  INCF   5C,F
019F:  BTFSC  03.2
01A0:  INCF   5D,F
01A1:  MOVWF  64
01A2:  MOVF   7A,W
01A3:  MOVWF  65
01A4:  SUBLW  02
01A5:  BTFSC  03.0
01A6:  GOTO   1B4
01A7:  XORLW  FF
01A8:  BTFSS  03.2
01A9:  GOTO   1AE
01AA:  MOVF   64,W
01AB:  SUBLW  E8
01AC:  BTFSC  03.0
01AD:  GOTO   1B4
....................         return(0); else delay_ms(1); 
01AE:  CLRF   77
01AF:  CLRF   78
01B0:  CLRF   79
01B1:  CLRF   7A
01B2:  GOTO   208
01B3:  GOTO   1BB
01B4:  MOVLW  01
01B5:  MOVWF  64
01B6:  BCF    03.5
01B7:  BCF    03.6
01B8:  CALL   0F4
01B9:  BSF    03.5
01BA:  BSF    03.6
....................     } 
01BB:  BCF    03.5
01BC:  BCF    03.6
01BD:  GOTO   192
....................     data.b[3]=spi_read(command.b[1]);        // Read first byte and send first adc command 
01BE:  MOVF   13,W
01BF:  BSF    03.5
01C0:  BSF    03.6
01C1:  MOVF   63,W
01C2:  BCF    03.5
01C3:  BCF    03.6
01C4:  MOVWF  13
01C5:  BSF    03.5
01C6:  RRF    14,W
01C7:  BTFSS  03.0
01C8:  GOTO   1C6
01C9:  BCF    03.5
01CA:  MOVF   13,W
01CB:  BSF    03.5
01CC:  BSF    03.6
01CD:  MOVWF  61
....................     data.b[2]=spi_read(command.b[0]);        // Read second byte and send last adc command 
01CE:  BCF    03.5
01CF:  BCF    03.6
01D0:  MOVF   13,W
01D1:  BSF    03.5
01D2:  BSF    03.6
01D3:  MOVF   62,W
01D4:  BCF    03.5
01D5:  BCF    03.6
01D6:  MOVWF  13
01D7:  BSF    03.5
01D8:  RRF    14,W
01D9:  BTFSS  03.0
01DA:  GOTO   1D8
01DB:  BCF    03.5
01DC:  MOVF   13,W
01DD:  BSF    03.5
01DE:  BSF    03.6
01DF:  MOVWF  60
....................     data.b[1]=spi_read(0x00);                // Read third byte 
01E0:  BCF    03.5
01E1:  BCF    03.6
01E2:  MOVF   13,W
01E3:  CLRF   13
01E4:  BSF    03.5
01E5:  RRF    14,W
01E6:  BTFSS  03.0
01E7:  GOTO   1E5
01E8:  BCF    03.5
01E9:  MOVF   13,W
01EA:  BSF    03.5
01EB:  BSF    03.6
01EC:  MOVWF  5F
....................     data.b[0]=spi_read(0x00);                // Read last byte 
01ED:  BCF    03.5
01EE:  BCF    03.6
01EF:  MOVF   13,W
01F0:  CLRF   13
01F1:  BSF    03.5
01F2:  RRF    14,W
01F3:  BTFSS  03.0
01F4:  GOTO   1F2
01F5:  BCF    03.5
01F6:  MOVF   13,W
01F7:  BSF    03.5
01F8:  BSF    03.6
01F9:  MOVWF  5E
....................     output_high(LTC2449_CS);                 // Pull CS high 
01FA:  BCF    03.6
01FB:  BCF    06.5
01FC:  BCF    03.5
01FD:  BSF    06.5
....................     return(data.w); 
01FE:  BSF    03.5
01FF:  BSF    03.6
0200:  MOVF   5E,W
0201:  MOVWF  77
0202:  MOVF   5F,W
0203:  MOVWF  78
0204:  MOVF   60,W
0205:  MOVWF  79
0206:  MOVF   61,W
0207:  MOVWF  7A
.................... } 
0208:  BCF    03.6
0209:  BCF    03.5
020A:  BSF    0A.3
020B:  BCF    0A.4
020C:  GOTO   1C8 (RETURN)
....................  
.................... float LTC2449_voltage(long adc_code) 
.................... //Calculates the LTC2449 input bipolar voltage 
.................... { 
....................     float adc_voltage; 
....................     adc_code -= 536870912;                        // Converts offset binary to binary  
....................     adc_voltage=((float)adc_code-LTC2449_offset_code)*LTC2449_lsb; 
....................     return(adc_voltage); 
.................... } 
....................  
.................... void LTC2449_cal_voltage(long zero_code,long fs_code,float fs_voltage) 
.................... //Calibrate the lsb 
.................... {  
....................     zero_code -= 536870912;                       // Converts offset binary to binary  
....................     fs_code -= 536870912;                         // Converts offset binary to binary 
....................     LTC2449_offset_code=(float)zero_code; 
....................     LTC2449_lsb=fs_voltage/((float)fs_code-LTC2449_offset_code); 
.................... } 
.................... #endif 
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC2461\LTC2461.h" 
.................... /* 
.................... LTC2461 
.................... 16-BIT DELTA SIGMA ADC WITH I2C INTERFACE 
....................  
.................... I2C DATA FORMAT (MSB First): 
....................  
....................        Byte #1                                    Byte #2                       Byte #3 
....................  
.................... START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 W SACK  EN1 EN2 SPD SLP  XX  XX XX XX  SACK  STOP 
....................  
.................... START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 R SACK  D15 D14 D13 D12 D11 D10 D9 D8  SACK  D7 D6  D5  D4  D3  D2  D1  D0 NACK STOP 
....................  
....................  
.................... Sx   : Address Select Bit 
.................... EN1  : Enable 1 : to program, EN1 = High, EN2 = Low 
.................... EN2  : Enable 2 
.................... SPD  : Speed Bit- 0 for 60Hz, 1 for 30Hz 
.................... SLP  : Sleep Mode Bit 
.................... X    : Don't care 
.................... Dx   : Data Bits 
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 699 $ 
.................... $Date: 2012-10-12 13:52:06 -0700 (Fri, 12 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
.................... */ 
....................  
.................... #ifndef LTC2461_h 
.................... #define LTC2461_h 
....................  
.................... // Address Choices: 
.................... // To choose an address, comment out all options except the 
.................... // configuration on the demo board: 
....................  
.................... //LTC2461 I2C Addresses 
.................... #define LTC2461_I2C_ADDRESS    0x28   //  A0 = LOW : this is demo board default 
.................... // #define LTC2461_I2C_ADDRESS    0xA8   //  A0 = HIGH 
....................  
....................  
.................... //Command Constants 
.................... #define LTC2461_30HZ_SPEED_MODE    0xA0     // SPD=1 
.................... #define LTC2461_60HZ_SPEED_MODE    0x80     // SPD=0 
.................... #define LTC2461_SLEEP_MODE         0x90     // SLP=1 SPD=XX 
....................  
.................... //Calibration Variables 
.................... float LTC2461_lsb = 1.907377E-05; // Vref/(2^16)-1 
.................... float LTC2461_offset_code=0; 
....................  
.................... unsigned char LTC2461_read(unsigned char i2c_address, unsigned char adc_command, long& code) 
.................... //Reads 16 bits. Derived from LTC2309. 
.................... { 
*
09D7:  CLRF   5C
....................     unsigned char ack = 0; 
....................     union {unsigned char b[4];long w;} data;    // LTC2461 data 
....................     i2c_start();                                // write an I2C start bit 
09D8:  BCF    03.5
09D9:  BCF    03.6
09DA:  BSF    20.5
09DB:  MOVF   20,W
09DC:  BSF    03.5
09DD:  MOVWF  07
09DE:  MOVLW  04
09DF:  MOVWF  77
09E0:  DECFSZ 77,F
09E1:  GOTO   1E0
09E2:  BCF    03.5
09E3:  BSF    20.3
09E4:  MOVF   20,W
09E5:  BSF    03.5
09E6:  MOVWF  07
09E7:  MOVLW  03
09E8:  MOVWF  77
09E9:  DECFSZ 77,F
09EA:  GOTO   1E9
09EB:  BCF    03.5
09EC:  BCF    07.5
09ED:  BCF    20.5
09EE:  MOVF   20,W
09EF:  BSF    03.5
09F0:  MOVWF  07
09F1:  MOVLW  04
09F2:  MOVWF  77
09F3:  DECFSZ 77,F
09F4:  GOTO   1F3
09F5:  BCF    03.5
09F6:  BCF    07.3
09F7:  BCF    20.3
09F8:  MOVF   20,W
09F9:  BSF    03.5
09FA:  MOVWF  07
....................     ack = i2c_write(i2c_address & 0xFE);        // write the I2C 8 bit address and configure for programming 
09FB:  BSF    03.6
09FC:  MOVF   5A,W
09FD:  ANDLW  FE
09FE:  MOVWF  61
09FF:  MOVWF  66
0A00:  BCF    0A.3
0A01:  BCF    03.5
0A02:  BCF    03.6
0A03:  CALL   034
0A04:  BSF    0A.3
0A05:  MOVF   78,W
0A06:  BSF    03.5
0A07:  BSF    03.6
0A08:  MOVWF  5C
....................     if(!ack) 
0A09:  MOVF   5C,F
0A0A:  BTFSS  03.2
0A0B:  GOTO   262
....................     { 
....................         ack = i2c_write(adc_command);           // write the command byte 
0A0C:  MOVF   5B,W
0A0D:  MOVWF  66
0A0E:  BCF    0A.3
0A0F:  BCF    03.5
0A10:  BCF    03.6
0A11:  CALL   034
0A12:  BSF    0A.3
0A13:  MOVF   78,W
0A14:  BSF    03.5
0A15:  BSF    03.6
0A16:  MOVWF  5C
....................         i2c_start(); 
0A17:  BCF    03.5
0A18:  BCF    03.6
0A19:  BSF    20.5
0A1A:  MOVF   20,W
0A1B:  BSF    03.5
0A1C:  MOVWF  07
0A1D:  MOVLW  04
0A1E:  MOVWF  77
0A1F:  DECFSZ 77,F
0A20:  GOTO   21F
0A21:  BCF    03.5
0A22:  BSF    20.3
0A23:  MOVF   20,W
0A24:  BSF    03.5
0A25:  MOVWF  07
0A26:  MOVLW  03
0A27:  MOVWF  77
0A28:  DECFSZ 77,F
0A29:  GOTO   228
0A2A:  BCF    03.5
0A2B:  BTFSS  07.3
0A2C:  GOTO   22B
0A2D:  BCF    07.5
0A2E:  BCF    20.5
0A2F:  MOVF   20,W
0A30:  BSF    03.5
0A31:  MOVWF  07
0A32:  MOVLW  04
0A33:  MOVWF  77
0A34:  DECFSZ 77,F
0A35:  GOTO   234
0A36:  BCF    03.5
0A37:  BCF    07.3
0A38:  BCF    20.3
0A39:  MOVF   20,W
0A3A:  BSF    03.5
0A3B:  MOVWF  07
....................         ack=i2c_write(i2c_address | 0x01);      // write the I2C 8 bit address and !R bit in the LSB position 
0A3C:  BSF    03.6
0A3D:  MOVF   5A,W
0A3E:  IORLW  01
0A3F:  MOVWF  61
0A40:  MOVWF  66
0A41:  BCF    0A.3
0A42:  BCF    03.5
0A43:  BCF    03.6
0A44:  CALL   034
0A45:  BSF    0A.3
0A46:  MOVF   78,W
0A47:  BSF    03.5
0A48:  BSF    03.6
0A49:  MOVWF  5C
....................         if(!ack) 
0A4A:  MOVF   5C,F
0A4B:  BTFSS  03.2
0A4C:  GOTO   262
....................         { 
....................             data.b[1]=i2c_read(0);              // reads MSB byte with ACK 
0A4D:  CLRF   77
0A4E:  BCF    0A.3
0A4F:  BCF    03.5
0A50:  BCF    03.6
0A51:  CALL   092
0A52:  BSF    0A.3
0A53:  MOVF   78,W
0A54:  BSF    03.5
0A55:  BSF    03.6
0A56:  MOVWF  5E
....................             data.b[0]=i2c_read(1);              // reads LSB byte with Nack 
0A57:  MOVLW  01
0A58:  MOVWF  77
0A59:  BCF    0A.3
0A5A:  BCF    03.5
0A5B:  BCF    03.6
0A5C:  CALL   092
0A5D:  BSF    0A.3
0A5E:  MOVF   78,W
0A5F:  BSF    03.5
0A60:  BSF    03.6
0A61:  MOVWF  5D
....................         } 
....................     } 
....................     i2c_stop();                                 // write an I2C stop bit 
0A62:  BCF    03.5
0A63:  BCF    03.6
0A64:  BCF    20.5
0A65:  MOVF   20,W
0A66:  BSF    03.5
0A67:  MOVWF  07
0A68:  NOP
0A69:  BCF    03.5
0A6A:  BSF    20.3
0A6B:  MOVF   20,W
0A6C:  BSF    03.5
0A6D:  MOVWF  07
0A6E:  BCF    03.5
0A6F:  BTFSS  07.3
0A70:  GOTO   26F
0A71:  MOVLW  04
0A72:  MOVWF  77
0A73:  DECFSZ 77,F
0A74:  GOTO   273
0A75:  GOTO   276
0A76:  NOP
0A77:  BSF    20.5
0A78:  MOVF   20,W
0A79:  BSF    03.5
0A7A:  MOVWF  07
0A7B:  MOVLW  04
0A7C:  MOVWF  77
0A7D:  DECFSZ 77,F
0A7E:  GOTO   27D
....................     code = data.w; 
0A7F:  BSF    03.6
0A80:  MOVF   60,W
0A81:  MOVWF  45
0A82:  MOVF   5F,W
0A83:  MOVWF  44
0A84:  MOVF   5E,W
0A85:  MOVWF  43
0A86:  MOVF   5D,W
0A87:  MOVWF  42
....................     return(ack); 
0A88:  MOVF   5C,W
0A89:  MOVWF  78
.................... } 
....................  
.................... unsigned char LTC2461_command(unsigned char i2c_address, unsigned char adc_command) 
.................... //Write a 16-bit command to the ADC. Derived from 2655. 
.................... //The function returns the state of the acknowledge bit after the I2C Address write. 0=acknowledge, 1=no acknowledge. 
.................... {      
....................     unsigned char ack = 0;   
....................     i2c_start();                                // write an I2C start bit 
....................     ack = i2c_write(i2c_address & 0xFE);        // write the I2C 8 bit address and !W bit in the LSB position 
....................     if(!ack) 
....................     { 
....................         ack = i2c_write(adc_command);           // write the command byte 
.................... 	} 
....................     i2c_stop();                                 // Write an I2C stop bit 
....................     return (ack); 
....................  
.................... } 
....................  
.................... float LTC2461_voltage( long adc_code) // Function definition 
.................... //Calculates the LTC2309 input unipolar voltage. 
.................... { 
....................     float adc_voltage; 
....................     adc_voltage=(adc_code- LTC2461_offset_code)*LTC2461_lsb; 
....................     return(adc_voltage);    
.................... } 
....................  
....................  
.................... void LTC2461_cal_voltage(long zero_code,long fs_code,float fs_voltage) // Function definition 
.................... //Calibrate the lsb 
.................... {  
....................     LTC2461_offset_code=(float)zero_code; 
....................     LTC2461_lsb=fs_voltage/((float)fs_code-LTC2461_offset_code); 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC2484\LTC2484.h" 
.................... /* 
....................  LTC2484  
....................  24-bit delta-sigma ADC with integrated temperature sensor and easy drive input 
....................  
....................  SPI DATA FORMAT (MSB First): 
....................   
....................  Byte #1                            Byte #2                           Byte #3                    Byte #4 
....................   
....................  Data Out :  !EOC DMY SIG D23 D22 D21 D20 D19   D18 D17 D16 D15 D14 D13 D12 D11   D10 D9 D8 D7 D6 D5 D4 D3  D2 D1 D0 X X X X X 
....................  Data In  :  EN   X   X   X   IM  FOA FOB SPD   X   X   X   X   X   X   X   X     X   X  X  X  X  X  X  X   X  X  X  X X X X X 
....................   
....................  !EOC : End of Conversion Bit (Active Low) 
....................  DMY  : Dummy Bit (Always 0) 
....................  SIG  : Sign Bit (1-data positive, 0-data negative) 
....................  Dx   : Data Bits 
....................  EN   : Enable Bit (0-keep previous mode, 1-change mode) 
....................  IM   : Internal Mode Bit (0-ADC input, 1-Temperature Sensor input) 
....................  FoA  : Line Frequency Rejection Select Bit A 
....................  FoB  : Line Frequency Rejection Select Bit B 
....................  SPD  : Double Output Rate Select Bit (0-Normal rate, auto-calibration on, 2x rate, auto_calibration off) 
....................  X    : Don't care   
....................  
....................  Command Byte 
....................  EN  IM   FoA  FoB  SPD   Comments 
....................  0    X    X    X    X    Keep Previous Mode 
....................  1    0    0    0    0    External Input, 50Hz and 60Hz Rejection, Autocalibration 
....................  1    0    0    1    0    External Input, 50Hz Rejection, Autocalibration 
....................  1    0    1    0    0    External Input, 60Hz Rejection, Autocalibration 
....................  1    0    0    0    1    External Input, 50Hz and 60Hz Rejection, 2x Speed 
....................  1    0    0    1    1    External Input, 50Hz Rejection, 2x Speed 
....................  1    0    1    0    1    External Input, 60Hz Rejection, 2x Speed 
....................  1    1    0    0    X    Temperature Input, 50Hz and 60Hz Rejection, Autocalibration 
....................  1    1    0    1    X    Temperature Input, 50Hz Rejection, Autocalibration 
....................  1    1    1    0    X    Temperature Input, 60Hz Rejection, Autocalibration 
....................  1    X    1    1    X    Reserved, Do Not Use 
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 699 $ 
.................... $Date: 2012-10-12 13:52:06 -0700 (Fri, 12 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
....................  */ 
....................  
.................... #ifndef LTC2484_h 
.................... #define LTC2484_h 
....................  
.................... //define the CS pin 
.................... #ifndef LTC2484_CS 
.................... #define LTC2484_CS CS 
.................... #endif 
....................  
.................... //MISO timeout in ms 
.................... #define MISO_timeout 1000 
....................  
.................... //calibration variables 
.................... float LTC2484_lsb = 9.3132258E-9; // 5V/(2^29) 
.................... float LTC2484_offset_code=0; 
.................... float LTC2484_t0 = 27.0;          // Reference temperature 
.................... float LTC2484_r0 = 45.097156E6;   // ADC code at the reference temperature (420mV default) 
....................  
.................... //Command constants. OR together to form the adc_command byte. 
.................... #define LTC2484_ENABLE              0x80 
.................... #define LTC2484_DISABLE             0x00 
.................... // 
.................... #define LTC2484_EXTERNAL_INPUT      0x00 
.................... #define LTC2484_TEMPERATURE_INPUT   0x08 
.................... // 
.................... #define LTC2484_REJECTION_50HZ_60HZ 0x00 
.................... #define LTC2484_REJECTION_50HZ      0x02 
.................... #define LTC2484_REJECTION_60HZ      0x04 
.................... // 
.................... #define LTC2484_AUTO_CALIBRATION    0x00 
.................... #define LTC2484_SPEED_2X            0x01 
....................  
.................... // Commands 
.................... // Construct enable with any other command to form an int command. You can also enable 2Xmode, 
.................... // which will increase sample rate by a facor of 2.  
....................  
.................... // Example - read channel external input with 60Hz rejection and 2X enabled. 
.................... // adc_command = (LTC2484_EXTERNAL_INPUT | LTC2484_REJECTION_60HZ) | LTC2484_SPEED_2X; 
....................  
.................... long LTC2484_read(unsigned char adc_command) 
.................... { 
*
020D:  BSF    03.5
020E:  BSF    03.6
020F:  CLRF   5C
0210:  CLRF   5B
....................     unsigned int timer_count = 0;            // Timer count for MISO 
....................     union {unsigned char b[4];long w;} data; // LTC2484 data 
....................     output_low(LTC2484_CS);                  // Pull CS low  
0211:  BCF    03.6
0212:  BCF    06.5
0213:  BCF    03.5
0214:  BCF    06.5
....................     while(1)                                 // wait for SDO (MISO) to go low  
....................     { 
....................         if(input(MISO)==0) break;            // If SDO is low, break loop 
0215:  BSF    20.4
0216:  MOVF   20,W
0217:  BSF    03.5
0218:  MOVWF  07
0219:  BCF    03.5
021A:  BTFSS  07.4
021B:  GOTO   241
....................         if(timer_count++>MISO_timeout)       // If timeout, return 0 
021C:  BSF    03.5
021D:  BSF    03.6
021E:  MOVF   5C,W
021F:  MOVWF  7A
0220:  MOVF   5B,W
0221:  INCF   5B,F
0222:  BTFSC  03.2
0223:  INCF   5C,F
0224:  MOVWF  61
0225:  MOVF   7A,W
0226:  MOVWF  62
0227:  SUBLW  02
0228:  BTFSC  03.0
0229:  GOTO   237
022A:  XORLW  FF
022B:  BTFSS  03.2
022C:  GOTO   231
022D:  MOVF   61,W
022E:  SUBLW  E8
022F:  BTFSC  03.0
0230:  GOTO   237
....................         return(0); else delay_ms(1); 
0231:  CLRF   77
0232:  CLRF   78
0233:  CLRF   79
0234:  CLRF   7A
0235:  GOTO   286
0236:  GOTO   23E
0237:  MOVLW  01
0238:  MOVWF  64
0239:  BCF    03.5
023A:  BCF    03.6
023B:  CALL   0F4
023C:  BSF    03.5
023D:  BSF    03.6
....................     } 
023E:  BCF    03.5
023F:  BCF    03.6
0240:  GOTO   215
....................     data.b[3]=spi_read(adc_command);         // Read first byte and send first adc command 
0241:  MOVF   13,W
0242:  BSF    03.5
0243:  BSF    03.6
0244:  MOVF   5A,W
0245:  BCF    03.5
0246:  BCF    03.6
0247:  MOVWF  13
0248:  BSF    03.5
0249:  RRF    14,W
024A:  BTFSS  03.0
024B:  GOTO   249
024C:  BCF    03.5
024D:  MOVF   13,W
024E:  BSF    03.5
024F:  BSF    03.6
0250:  MOVWF  60
....................     data.b[2]=spi_read(0x00);                // Read second byte and send last adc command 
0251:  BCF    03.5
0252:  BCF    03.6
0253:  MOVF   13,W
0254:  CLRF   13
0255:  BSF    03.5
0256:  RRF    14,W
0257:  BTFSS  03.0
0258:  GOTO   256
0259:  BCF    03.5
025A:  MOVF   13,W
025B:  BSF    03.5
025C:  BSF    03.6
025D:  MOVWF  5F
....................     data.b[1]=spi_read(0x00);                // Read third byte 
025E:  BCF    03.5
025F:  BCF    03.6
0260:  MOVF   13,W
0261:  CLRF   13
0262:  BSF    03.5
0263:  RRF    14,W
0264:  BTFSS  03.0
0265:  GOTO   263
0266:  BCF    03.5
0267:  MOVF   13,W
0268:  BSF    03.5
0269:  BSF    03.6
026A:  MOVWF  5E
....................     data.b[0]=spi_read(0x00);                // Read last byte 
026B:  BCF    03.5
026C:  BCF    03.6
026D:  MOVF   13,W
026E:  CLRF   13
026F:  BSF    03.5
0270:  RRF    14,W
0271:  BTFSS  03.0
0272:  GOTO   270
0273:  BCF    03.5
0274:  MOVF   13,W
0275:  BSF    03.5
0276:  BSF    03.6
0277:  MOVWF  5D
....................     output_high(LTC2484_CS);                 // Pull CS high 
0278:  BCF    03.6
0279:  BCF    06.5
027A:  BCF    03.5
027B:  BSF    06.5
....................     return(data.w); 
027C:  BSF    03.5
027D:  BSF    03.6
027E:  MOVF   5D,W
027F:  MOVWF  77
0280:  MOVF   5E,W
0281:  MOVWF  78
0282:  MOVF   5F,W
0283:  MOVWF  79
0284:  MOVF   60,W
0285:  MOVWF  7A
.................... } 
0286:  BCF    03.6
0287:  BCF    03.5
0288:  BSF    0A.3
0289:  BCF    0A.4
028A:  GOTO   292 (RETURN)
....................  
.................... float LTC2484_voltage(long adc_code) 
.................... //Calculates the LTC2484 input bipolar voltage 
.................... { 
....................     float adc_voltage; 
....................     adc_code -= 0x20000000;                         
....................     adc_voltage=((float)adc_code-LTC2484_offset_code)*LTC2484_lsb; 
....................     return(adc_voltage); 
.................... } 
....................  
.................... float LTC2484_temperature(long adc_code) 
.................... //Calculate the LTC2484 temperature. 
.................... { 
....................     adc_code -= 0x20000000;                     
....................     return (((((float) adc_code) / LTC2484_r0) * (LTC2484_t0 + 273)) - 273); 
.................... } 
....................  
.................... void LTC2484_cal_voltage(long zero_code,long fs_code,float fs_voltage) 
.................... //Calibrate the lsb 
.................... {  
....................     zero_code -= 0x20000000;                       // Converts offset binary to binary  
....................     fs_code -= 0x20000000;                         // Converts offset binary to binary 
....................     LTC2484_offset_code=(float)zero_code; 
....................     LTC2484_lsb=fs_voltage/((float)fs_code-LTC2484_offset_code); 
.................... } 
....................  
.................... void LTC2484_cal_temperature(long adc_code, float temperature) 
.................... //Calibrate temperature 
.................... { 
....................     adc_code -= 0x20000000;             // Converts offset binary to binary  
....................     LTC2484_r0 = (float) adc_code;      // Convert the adc_code to a float value   
....................     LTC2484_t0 = temperature;           // Store the calibration temperature 
.................... } 
....................  
.................... /* 
.................... float LTC2484_voltage(long adc_code) 
.................... //Calculate the LTC2449 input voltage. 
.................... { 
....................     float adc_voltage; 
....................     adc_voltage = ((float) adc_code - LTC2484_offset_code) * LTC2484_lsb; 
....................     return (adc_voltage); 
.................... } 
....................  
.................... float LTC2484_temperature(long adc_code) 
.................... //Calculate the LTC2449 temperature. 
.................... { 
....................     return (((((float) adc_code) / LTC2484_r0) * (LTC2484_t0 + 273)) - 273); 
.................... } 
....................  
.................... void LTC2484_cal_voltage(long zero_code, long fs_code, float fs_voltage) 
.................... //Calibrate the lsb 
.................... { 
....................     LTC2484_offset_code = (float) zero_code; 
....................     LTC2484_lsb = fs_voltage / ((float) fs_code - LTC2484_offset_code); 
.................... } 
....................  
.................... void LTC2484_cal_temperature(long adc_code, float temperature) 
.................... //Calibrate temperature 
.................... { 
....................     LTC2484_r0 = (float) adc_code;      // Convert the adc_code to a float value   
....................     LTC2484_t0 = temperature;           // Store the calibration temperature 
.................... } 
.................... */ 
.................... #endif 
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC2640\LTC2640.h" 
.................... /* 
....................  LTC2640  
....................  Single 12-/10-/8-Bit Rail-to- Rail DACs with 10ppm/C Reference 
....................  
....................  SPI DATA FORMAT (MSB First): 
....................   
....................  Byte #1               Byte #2                     Byte #3 
....................  Command               MSB                         LSB 
....................  LTC2640-12 :    C3 C2 C1 C0 X X X X   D11 D10 D9 D8 D7 D6 D5 D4   D3 D2 D1 D0 X X X X 
....................  LTC2640-10 :    C3 C2 C1 C0 X X X X   D9  D8  D7 D6 D5 D4 D3 D2   D1 D0 X  X  X X X X 
....................  LTC2640-8  :    C3 C2 C1 C0 X X X X   D7  D6  D5 D4 D3 D2 D1 D0   X  X  X  X  X X X X 
....................   
....................  Cx : DAC Command 
....................  Dx : DAC Code 
....................  X  : Don't care    
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 717 $ 
.................... $Date: 2012-10-25 13:22:48 -0700 (Thu, 25 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
....................  */ 
....................  
.................... #ifndef LTC2640_h 
.................... #define LTC2640_h 
....................  
.................... //define the CS pin 
.................... #ifndef LTC2640_CS 
.................... #define LTC2640_CS CS 
.................... #endif 
....................  
.................... //LTC2640 Command Codes (C3-C0) 
.................... #define  LTC2640_cmd_write               0x00  // Write to input register 
.................... #define  LTC2640_cmd_update              0x10  // Update (power up) DAC register 
.................... #define  LTC2640_cmd_write_update        0x30  // Write to and update (power up) the DAC register 
.................... #define  LTC2640_cmd_power_down          0x40  // Power down 
.................... #define  LTC2640_cmd_internal_reference  0x60  // Select internal reference (default at power up) 
.................... #define  LTC2640_cmd_external_reference  0x70  // Select the supply as the reference 
....................  
.................... //calibration constants 
.................... float LTC2640_lsb = 1e-3;       // DAC lsb. Default to 12-bits 
.................... float LTC2640_offset = 0;       // DAC offset 
....................  
.................... void LTC2640_write(unsigned char dac_command, unsigned int dac_code) 
.................... //Write the 16-bit dac_code to the LTC2640. The dac_code must be left aligned before 
.................... //calling this function. 
.................... { 
....................     union{unsigned char b[2];unsigned int w;} data; 
....................     data.w = dac_code;          // Get dac code 
028B:  BSF    03.5
028C:  BSF    03.6
028D:  MOVF   5C,W
028E:  MOVWF  5E
028F:  MOVF   5B,W
0290:  MOVWF  5D
....................     output_low (LTC2640_CS);    // Pull CS low to start transaction 
0291:  BCF    03.6
0292:  BCF    06.5
0293:  BCF    03.5
0294:  BCF    06.5
....................     spi_write(dac_command);     // Write the command byte first 
0295:  MOVF   13,W
0296:  BSF    03.5
0297:  BSF    03.6
0298:  MOVF   5A,W
0299:  BCF    03.5
029A:  BCF    03.6
029B:  MOVWF  13
029C:  BSF    03.5
029D:  RRF    14,W
029E:  BTFSS  03.0
029F:  GOTO   29D
....................     spi_write(data.b[1]);       // Write the MSB  
02A0:  BCF    03.5
02A1:  MOVF   13,W
02A2:  BSF    03.5
02A3:  BSF    03.6
02A4:  MOVF   5E,W
02A5:  BCF    03.5
02A6:  BCF    03.6
02A7:  MOVWF  13
02A8:  BSF    03.5
02A9:  RRF    14,W
02AA:  BTFSS  03.0
02AB:  GOTO   2A9
....................     spi_write(data.b[0]);       // Write the LSB 
02AC:  BCF    03.5
02AD:  MOVF   13,W
02AE:  BSF    03.5
02AF:  BSF    03.6
02B0:  MOVF   5D,W
02B1:  BCF    03.5
02B2:  BCF    03.6
02B3:  MOVWF  13
02B4:  BSF    03.5
02B5:  RRF    14,W
02B6:  BTFSS  03.0
02B7:  GOTO   2B5
....................     output_high(LTC2640_CS);    // Pull CS high to finish transaction   
02B8:  BCF    06.5
02B9:  BCF    03.5
02BA:  BSF    06.5
.................... } 
02BB:  BSF    0A.3
02BC:  BCF    0A.4
02BD:  GOTO   2A7 (RETURN)
....................  
.................... unsigned int LTC2640_code(float dac_voltage) 
.................... //Calculate a LTC2640 DAC code given the desired output voltage   
.................... { 
....................     float float_code; 
....................     float_code = (dac_voltage - LTC2640_offset) / LTC2640_lsb;  // Calculate the DAC code 
....................     float_code = (float_code > (floor(float_code) + 0.5)) ? ceil(float_code) : floor(float_code); // Round 
....................     return ((unsigned int) (float_code));                       // Convert to unsigned integer  
.................... } 
....................  
.................... float LTC2640_voltage(unsigned int dac_code) 
.................... //Calculate the LTC2640 DAC output voltage given the DAC code 
.................... { 
....................     float dac_voltage; 
....................     dac_voltage = (((float) dac_code) * LTC2640_lsb) + LTC2640_offset; 
....................     return (dac_voltage); // return the dac_voltage 
.................... } 
....................  
.................... void LTC2640_calibrate(unsigned int dac_code1, unsigned int dac_code2, float voltage1, float voltage2) 
.................... //Calculate the LTC2640 offset and LSB voltage given two measured voltages and their corresponding codes 
.................... { 
....................     LTC2640_lsb = (voltage2 - voltage1) / ((float) (dac_code2 - dac_code1));    // Calculate the LSB 
....................     LTC2640_offset = voltage1 - ((LTC2640_lsb) * dac_code1);                    // Calculate the offset 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC2654\LTC2654.h" 
.................... /* 
....................  LTC2654 
....................  Quad SPI 16-/12-Bit Rail-to-Rail DACs with 10ppm/C Max Reference 
....................  
....................  SPI DATA FORMAT (MSB First): 
....................  
....................  24-Bit Load Sequence: 
....................    
....................               Byte #1                       Byte #2                       Byte #3                             
....................               Command                   MSB                             LSB 
....................  LTC2654-16 : C3 C2 C1 C0 A3 A2 A1 A0   D15 D14 D13 D12 D11 D10 D9 D8   D7 D6 D5 D4 D3 D2 D1 D0  
....................  LTC2654-12 : C3 C2 C1 C0 A3 A2 A1 A0   D11 D10 D9  D8  D7  D6  D5 D4   D3 D2 D1 D0 X  X  X  X 
....................  
....................  32-Bit Load Sequence:  
....................               Byte #1                       Byte #2                       Byte #3                 Byte #4            
....................               Command                   MSB                             LSB 
....................  LTC2654-16 : X  X  X  X  X  X  X  X    C3 C2 C1 C0 A3 A2 A1 A0   D15 D14 D13 D12 D11 D10 D9 D8   D7 D6 D5 D4 D3 D2 D1 D0  
....................  LTC2654-12 : X  X  X  X  X  X  X  X    C3 C2 C1 C0 A3 A2 A1 A0   D11 D10 D9  D8  D7  D6  D5 D4   D3 D2 D1 D0 X  X  X  X 
....................  
....................  Cx   : DAC Command Code 
....................  Ax   : DAC Address (0=DACA,1=DACB,2=DACC,3=DACD,0xFF=All DAC's) 
....................  Dx   : DAC Data Bits   
....................  X    : Don't care 
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 719 $ 
.................... $Date: 2012-10-26 14:22:35 -0700 (Fri, 26 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
.................... */ 
....................  
.................... #ifndef LTC2654_h 
.................... #define LTC2654_h 
....................  
.................... //define the CS pin 
.................... #ifndef LTC2654_CS 
.................... #define LTC2654_CS CS 
.................... #endif 
....................  
.................... //LTC2654 Command Codes 
.................... //OR'd together with the DAC address to form the command byte 
.................... #define  LTC2654_cmd_write               0x00  // Write to input register n 
.................... #define  LTC2654_cmd_update              0x10  // Update (power up) DAC register n 
.................... #define  LTC2654_cmd_write_update        0x30  // Write to input register n, update (power-up) all 
.................... #define  LTC2654_cmd_power_down          0x40  // Power down n 
.................... #define  LTC2654_cmd_power_down_all      0x50  // Power down chip (all DAC's and reference) 
.................... #define  LTC2654_cmd_internal_reference  0x60  // Select internal reference (power-up reference) 
.................... #define  LTC2654_cmd_external_reference  0x70  // Select external reference (power-down internal reference) 
.................... #define  LTC2654_cmd_no_operation        0xF0  // No operation 
.................... //LTC2654 DAC addresses 
.................... #define  LTC2654_DAC_A     0x00 
.................... #define  LTC2654_DAC_B     0x01 
.................... #define  LTC2654_DAC_C     0x02 
.................... #define  LTC2654_DAC_D     0x03 
.................... #define  LTC2654_DAC_ALL   0x0F 
....................  
.................... // Command Example - write to dac address D and update all.  
.................... // dac_command = LTC2654_cmd_write_update | LTC2654_DAC_D; 
....................  
.................... //Global calibration variables 
.................... float LTC2654_offset[4]; // DAC offset 
.................... float LTC2654_lsb[4];    // The LTC2654 lsb 
....................  
.................... void LTC2654_write(unsigned int dac_command, unsigned char dac_address, unsigned int dac_code) 
.................... //Write the 16-bit dac_code to the LTC2654 
.................... { 
....................     unsigned char command_byte; 
....................     union{unsigned char b[2];unsigned int w;} data;   
....................     data.w = dac_code;                              // Get dac code 
02BE:  BSF    03.5
02BF:  BSF    03.6
02C0:  MOVF   5E,W
02C1:  MOVWF  61
02C2:  MOVF   5D,W
02C3:  MOVWF  60
....................     command_byte = dac_command | dac_address;       // Build the DAC command byte   
02C4:  MOVF   5A,W
02C5:  IORWF  5C,W
02C6:  MOVWF  5F
....................     output_low (LTC2654_CS);                        // Pull CS low to start transaction 
02C7:  BCF    03.6
02C8:  BCF    06.5
02C9:  BCF    03.5
02CA:  BCF    06.5
....................     spi_write(command_byte);                        // Write the command and address  
02CB:  MOVF   13,W
02CC:  BSF    03.5
02CD:  BSF    03.6
02CE:  MOVF   5F,W
02CF:  BCF    03.5
02D0:  BCF    03.6
02D1:  MOVWF  13
02D2:  BSF    03.5
02D3:  RRF    14,W
02D4:  BTFSS  03.0
02D5:  GOTO   2D3
....................     spi_write(data.b[1]);                           // Write the MSB  
02D6:  BCF    03.5
02D7:  MOVF   13,W
02D8:  BSF    03.5
02D9:  BSF    03.6
02DA:  MOVF   61,W
02DB:  BCF    03.5
02DC:  BCF    03.6
02DD:  MOVWF  13
02DE:  BSF    03.5
02DF:  RRF    14,W
02E0:  BTFSS  03.0
02E1:  GOTO   2DF
....................     spi_write(data.b[0]);                           // Write the LSB 
02E2:  BCF    03.5
02E3:  MOVF   13,W
02E4:  BSF    03.5
02E5:  BSF    03.6
02E6:  MOVF   60,W
02E7:  BCF    03.5
02E8:  BCF    03.6
02E9:  MOVWF  13
02EA:  BSF    03.5
02EB:  RRF    14,W
02EC:  BTFSS  03.0
02ED:  GOTO   2EB
....................     output_high(LTC2654_CS);                        // Pull CS high to finish transaction   
02EE:  BCF    06.5
02EF:  BCF    03.5
02F0:  BSF    06.5
.................... } 
02F1:  BSF    0A.3
02F2:  BCF    0A.4
02F3:  GOTO   2B7 (RETURN)
.................... unsigned int LTC2654_code(float dac_voltage, unsigned char dac_address) 
.................... //Calculate a LTC2654 DAC code given the desired output voltage and DAC address (0-3)  
.................... { 
....................     unsigned int dac_code; 
....................     float float_code; 
....................     if (dac_address > 3) 
....................         dac_address = 3;                                                                                // Check DAC address range 
....................     float_code = (dac_voltage - LTC2654_offset[dac_address]) / LTC2654_lsb[dac_address];                // Calculate the DAC code 
....................     float_code = (float_code > (floor(float_code) + 0.5)) ? ceil(float_code) : floor(float_code);       // Round 
....................     dac_code = (unsigned int) (float_code);                                                             // Convert to unsigned integer 
....................     return (dac_code); 
.................... } 
....................  
.................... float LTC2654_voltage(unsigned int dac_code, unsigned char dac_address) 
.................... //Calculate the LTC2654 DAC output voltage given the DAC code and DAC address (0-3) 
.................... { 
....................     float dac_voltage; 
....................     if (dac_address > 3) 
....................         dac_address = 3;                                                                                // Check DAC address range 
....................     dac_voltage = (((float) dac_code) * LTC2654_lsb[dac_address]) + LTC2654_offset[dac_address];        // Calculate the dac_voltage 
....................     return (dac_voltage); 
.................... } 
....................  
.................... void LTC2654_calibrate(unsigned int dac_code1, unsigned int dac_code2, float voltage1, float voltage2, unsigned char dac_address) 
.................... //Calculate the LTC2654 offset and LSB voltage given two measured voltages and their corresponding codes 
.................... { 
....................     if (dac_address > 3) 
....................         dac_address = 3;                                                                                // Check DAC address range 
....................     LTC2654_lsb[dac_address] = (voltage2 - voltage1) / ((float) (dac_code2 - dac_code1));               // Calculate the LSB 
....................     LTC2654_offset[dac_address] = voltage1 - (LTC2654_lsb[dac_address] * dac_code1);                    // Calculate the offset 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC2655\LTC2655.h" 
.................... /* 
....................  LTC2655  
....................  Quad I2C 16-/12-Bit Rail-to-Rail DACs with 10ppm/C Max Reference 
....................   
....................  I2C DATA FORMAT (MSB First): 
....................   
....................  Byte #1                                    Byte #2                       Byte #3                             Byte #4 
....................  MSB                                 LSB 
....................  LTC2630-16 : START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 W SACK  C3 C2 C1 C0 A3 A2 A1 A0 SACK  D15 D14 D13 D12 D11 D10 D9 D8 SACK  D7 D6 D5 D4 D3 D2 D1 D0 SACK  STOP 
....................  LTC2630-12 : START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 W SACK  C3 C2 C1 C0 A3 A2 A1 A0 SACK  D11 D10 D9  D8  D7  D6  D5 D4 SACK  D3 D2 D1 D0 X  X  X  X  SACK  STOP 
....................  
....................  START: I2C Start 
....................  SAx  : I2C Address 
....................  W    : I2C Write (0) 
....................  SACK : I2C Slave Generated Acknowledge (Active Low) 
....................  Cx   : DAC Command Code 
....................  Ax   : DAC Address (0=DACA,1=DACB,2=DACC,3=DACD,0xFF=All DAC's) 
....................  Dx   : DAC Data Bits   
....................  X    : Don't care 
....................  STOP : I2C Stop 
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 719 $ 
.................... $Date: 2012-10-26 14:22:35 -0700 (Fri, 26 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
....................  */ 
....................  
.................... #ifndef LTC2655_h 
.................... #define LTC2655_h 
....................  
.................... // Address Choices: 
.................... // To choose an address, comment out all options except the  
.................... // configuration on the demo board. 
....................  
....................                                       //  Address assignment 
.................... //LTC2655 I2C Address                 //  AD2       AD1       AD0 
.................... #define LTC2655_I2C_ADDRESS 0x20      //  GND       GND       GND 
.................... //#define LTC2655_I2C_ADDRESS 0x22    //  GND       GND       Float 
.................... //#define LTC2655_I2C_ADDRESS 0x24    //  GND       GND       Vcc 
.................... //#define LTC2655_I2C_ADDRESS 0x26    //  GND       Float     GND 
.................... //#define LTC2655_I2C_ADDRESS 0x40    //  GND       Float     Float 
.................... //#define LTC2655_I2C_ADDRESS 0x42    //  GND       Float     Vcc 
.................... //#define LTC2655_I2C_ADDRESS 0x44    //  GND       Vcc       GND 
.................... //#define LTC2655_I2C_ADDRESS 0x46    //  GND       Vcc       Float 
.................... //#define LTC2655_I2C_ADDRESS 0x60    //  GND       Vcc       Vcc 
.................... //#define LTC2655_I2C_ADDRESS 0x62    //  Float     GND       GND 
.................... //#define LTC2655_I2C_ADDRESS 0x64    //  Float     GND       Float 
.................... //#define LTC2655_I2C_ADDRESS 0x66    //  Float     GND       Vcc 
.................... //#define LTC2655_I2C_ADDRESS 0x80    //  Float     Float     GND 
.................... //#define LTC2655_I2C_ADDRESS 0x82    //  Float     Float     Float 
.................... //#define LTC2655_I2C_ADDRESS 0x84    //  Float     Float     Vcc 
.................... //#define LTC2655_I2C_ADDRESS 0x86    //  Float     Vcc       GND 
.................... //#define LTC2655_I2C_ADDRESS 0xA0    //  Float     Vcc       Float 
.................... //#define LTC2655_I2C_ADDRESS 0xA2    //  Float     Vcc       Vcc 
.................... //#define LTC2655_I2C_ADDRESS 0xA4    //  Vcc       GND       GND 
.................... //#define LTC2655_I2C_ADDRESS 0xA6    //  Vcc       GND       Float 
.................... //#define LTC2655_I2C_ADDRESS 0xC0    //  Vcc       GND       Vcc 
.................... //#define LTC2655_I2C_ADDRESS 0xC2    //  Vcc       Float     GND 
.................... //#define LTC2655_I2C_ADDRESS 0xC4    //  Vcc       Float     Float 
.................... //#define LTC2655_I2C_ADDRESS 0xC6    //  Vcc       Float     Vcc 
.................... //#define LTC2655_I2C_ADDRESS 0xE0    //  Vcc       Vcc       GND 
.................... //#define LTC2655_I2C_ADDRESS 0xE2    //  Vcc       Vcc       Float 
.................... //#define LTC2655_I2C_ADDRESS 0xE6    //  Vcc       Vcc       Vcc 
....................  
.................... #define LTC2655_I2C_GLOBAL_ADDRESS  0xE6        // LTC2655 global address 
....................  
.................... //LTC2655 Command Codes 
.................... //OR'd together with the DAC address to form the command byte 
.................... #define  LTC2655_cmd_write               0x00   // Write to input register n 
.................... #define  LTC2655_cmd_update              0x10   // Update (power up) DAC register n 
.................... #define  LTC2655_cmd_write_update        0x30   // Write to input register n, update (power-up) all 
.................... #define  LTC2655_cmd_power_down          0x40   // Power down n 
.................... #define  LTC2655_cmd_power_down_all      0x50   // Power down chip (all DAC's and reference) 
.................... #define  LTC2655_cmd_internal_reference  0x60   // Select internal reference (power-up reference) 
.................... #define  LTC2655_cmd_external_reference  0x70   // Select external reference (power-down internal reference) 
.................... #define  LTC2655_cmd_no_operation        0xF0   // No operation 
.................... //LTC2655 DAC addresses 
.................... #define  LTC2655_DAC_A     0x00 
.................... #define  LTC2655_DAC_B     0x01 
.................... #define  LTC2655_DAC_C     0x02 
.................... #define  LTC2655_DAC_D     0x03 
.................... #define  LTC2655_DAC_ALL   0x0F 
....................  
.................... // Command Example - write to dac address D and update all.  
.................... // dac_command = LTC2654_cmd_write_update | LTC2654_DAC_D; 
....................  
.................... //Global calibration variables 
.................... float LTC2655_offset[4]; // DAC offset 
.................... float LTC2655_lsb[4];    // The LTC2655 lsb 
....................  
.................... unsigned char LTC2655_write(unsigned char i2c_address, unsigned char dac_command, unsigned char dac_address, unsigned int dac_code) 
.................... //Write a 16-bit dac_code to the LTC2655. 
.................... //The function returns the state of the acknowledge bit after the I2C Address write. 0=acknowledge, 1=no acknowledge. 
.................... { 
....................     unsigned char ACK; 
....................     unsigned char command_byte; 
....................     union{unsigned char b[2];unsigned int w;} data; 
....................     data.w = dac_code;                              // Get dac code 
02F4:  BSF    03.5
02F5:  BSF    03.6
02F6:  MOVF   5E,W
02F7:  MOVWF  62
02F8:  MOVF   5D,W
02F9:  MOVWF  61
....................     command_byte = dac_command | dac_address;       // Build the DAC command byte 
02FA:  MOVF   5B,W
02FB:  IORWF  5C,W
02FC:  MOVWF  60
....................     i2c_start();                                    // Write an I2C start bit 
02FD:  BCF    03.5
02FE:  BCF    03.6
02FF:  BSF    20.5
0300:  MOVF   20,W
0301:  BSF    03.5
0302:  MOVWF  07
0303:  MOVLW  04
0304:  MOVWF  77
0305:  DECFSZ 77,F
0306:  GOTO   305
0307:  BCF    03.5
0308:  BSF    20.3
0309:  MOVF   20,W
030A:  BSF    03.5
030B:  MOVWF  07
030C:  MOVLW  03
030D:  MOVWF  77
030E:  DECFSZ 77,F
030F:  GOTO   30E
0310:  BCF    03.5
0311:  BCF    07.5
0312:  BCF    20.5
0313:  MOVF   20,W
0314:  BSF    03.5
0315:  MOVWF  07
0316:  MOVLW  04
0317:  MOVWF  77
0318:  DECFSZ 77,F
0319:  GOTO   318
031A:  BCF    03.5
031B:  BCF    07.3
031C:  BCF    20.3
031D:  MOVF   20,W
031E:  BSF    03.5
031F:  MOVWF  07
....................     ACK = i2c_write(i2c_address &  0xFE);           // Write the I2C 8 bit address and !W bit in the LSB position 
0320:  BSF    03.6
0321:  MOVF   5A,W
0322:  ANDLW  FE
0323:  MOVWF  63
0324:  MOVWF  66
0325:  BCF    03.5
0326:  BCF    03.6
0327:  CALL   034
0328:  MOVF   78,W
0329:  BSF    03.5
032A:  BSF    03.6
032B:  MOVWF  5F
....................     if (!ACK)                                       // Check acknowledge status. 0=acknowledge, 1=no acknowledge 
032C:  MOVF   5F,F
032D:  BTFSS  03.2
032E:  GOTO   344
....................     { 
....................         i2c_write(command_byte);                    // Write the command byte 
032F:  MOVF   60,W
0330:  MOVWF  66
0331:  BCF    03.5
0332:  BCF    03.6
0333:  CALL   034
....................         i2c_write(data.b[1]);                       // Write the MSB 
0334:  BSF    03.5
0335:  BSF    03.6
0336:  MOVF   62,W
0337:  MOVWF  66
0338:  BCF    03.5
0339:  BCF    03.6
033A:  CALL   034
....................         i2c_write(data.b[0]);                       // Write the LSB  
033B:  BSF    03.5
033C:  BSF    03.6
033D:  MOVF   61,W
033E:  MOVWF  66
033F:  BCF    03.5
0340:  BCF    03.6
0341:  CALL   034
0342:  BSF    03.5
0343:  BSF    03.6
....................     } 
....................     i2c_stop();                                     // Write an I2C stop bit 
0344:  BCF    03.5
0345:  BCF    03.6
0346:  BCF    20.5
0347:  MOVF   20,W
0348:  BSF    03.5
0349:  MOVWF  07
034A:  NOP
034B:  BCF    03.5
034C:  BSF    20.3
034D:  MOVF   20,W
034E:  BSF    03.5
034F:  MOVWF  07
0350:  BCF    03.5
0351:  BTFSS  07.3
0352:  GOTO   351
0353:  MOVLW  04
0354:  MOVWF  77
0355:  DECFSZ 77,F
0356:  GOTO   355
0357:  GOTO   358
0358:  NOP
0359:  BSF    20.5
035A:  MOVF   20,W
035B:  BSF    03.5
035C:  MOVWF  07
035D:  MOVLW  04
035E:  MOVWF  77
035F:  DECFSZ 77,F
0360:  GOTO   35F
....................     return (ACK); 
0361:  BSF    03.6
0362:  MOVF   5F,W
0363:  MOVWF  78
.................... } 
0364:  BCF    03.6
0365:  BCF    03.5
0366:  BSF    0A.3
0367:  BCF    0A.4
0368:  GOTO   2C8 (RETURN)
....................  
.................... unsigned int LTC2655_code(float dac_voltage, unsigned char dac_address) 
.................... //Calculate a LTC2655 DAC code given the desired output voltage and DAC address (0-3)  
.................... { 
....................     unsigned int dac_code; 
....................     float float_code; 
....................     if (dac_address > 3) 
....................         dac_address = 3;                                                                            // Check DAC address range 
....................     float_code = (dac_voltage - LTC2655_offset[dac_address]) / LTC2655_lsb[dac_address];            // Calculate the DAC code 
....................     float_code = (float_code > (floor(float_code) + 0.5)) ? ceil(float_code) : floor(float_code);   // Round 
....................     dac_code = (unsigned int) (float_code);                                                         // Convert to unsigned integer 
....................     return (dac_code); 
.................... } 
....................  
.................... float LTC2655_voltage(unsigned int dac_code, unsigned char dac_address) 
.................... //Calculate the LTC2655 DAC output voltage given the DAC code and DAC address (0-3) 
.................... { 
....................     float dac_voltage; 
....................     if (dac_address > 3) 
....................         dac_address = 3;                                                                            // Check DAC address range 
....................     dac_voltage = (((float) dac_code) * LTC2655_lsb[dac_address]) + LTC2655_offset[dac_address];    // Calculate the dac_voltage 
....................     return (dac_voltage); 
.................... } 
....................  
.................... void LTC2655_calibrate(unsigned int dac_code1, unsigned int dac_code2, float voltage1, float voltage2, unsigned char dac_address) 
.................... //Calculate the LTC2655 offset and LSB voltage given two measured voltages and their corresponding codes 
.................... { 
....................     if (dac_address > 3) 
....................         dac_address = 3;                                                                            // Check DAC address range 
....................     LTC2655_lsb[dac_address] = (voltage2 - voltage1) / ((float) (dac_code2 - dac_code1));           // Calculate the LSB 
....................     LTC2655_offset[dac_address] = voltage1 - (LTC2655_lsb[dac_address] * dac_code1);                // Calculate the offset 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC2656\LTC2656.h" 
.................... /* 
....................  LTC2656  
....................  Quad SPI 16-/12-Bit Rail-to-Rail DACs with 10ppm/C Max Reference 
....................  
....................   
....................  SPI DATA FORMAT (MSB First): 
....................  
....................  24-Bit Load Sequence: 
....................    
....................               Byte #1                       Byte #2                       Byte #3                             
....................               Command                   MSB                             LSB 
....................  LTC2656-16 : C3 C2 C1 C0 A3 A2 A1 A0   D15 D14 D13 D12 D11 D10 D9 D8   D7 D6 D5 D4 D3 D2 D1 D0  
....................  LTC2656-12 : C3 C2 C1 C0 A3 A2 A1 A0   D11 D10 D9  D8  D7  D6  D5 D4   D3 D2 D1 D0 X  X  X  X 
....................  
....................  32-Bit Load Sequence:  
....................               Byte #1                       Byte #2                       Byte #3                 Byte #4            
....................               Command                   MSB                             LSB 
....................  LTC2656-16 : X  X  X  X  X  X  X  X    C3 C2 C1 C0 A3 A2 A1 A0   D15 D14 D13 D12 D11 D10 D9 D8   D7 D6 D5 D4 D3 D2 D1 D0  
....................  LTC2656-12 : X  X  X  X  X  X  X  X    C3 C2 C1 C0 A3 A2 A1 A0   D11 D10 D9  D8  D7  D6  D5 D4   D3 D2 D1 D0 X  X  X  X 
....................  
....................  Cx   : DAC Command Code 
....................  Ax   : DAC Address (0=DACA,1=DACB,2=DACC,3=DACD,4=DACE,5=DACF,6=DACG,7=DACH,0xFF=All DAC's) 
....................  Dx   : DAC Data Bits   
....................  X    : Don't care 
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 719 $ 
.................... $Date: 2012-10-26 14:22:35 -0700 (Fri, 26 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
.................... */ 
....................  
.................... #ifndef LTC2656_h 
.................... #define LTC2656_h 
....................  
.................... //Define the CS pin 
.................... #ifndef LTC2656_CS 
.................... #define LTC2656_CS CS 
.................... #endif 
....................  
.................... //LTC2656 Command Codes 
.................... //OR'd together with the DAC address to form the command byte 
.................... #define  LTC2656_cmd_write               0x00  // Write to input register n 
.................... #define  LTC2656_cmd_update              0x10  // Update (power up) DAC register n 
.................... #define  LTC2656_cmd_write_update        0x30  // Write to input register n, update (power-up) all 
.................... #define  LTC2656_cmd_power_down          0x40  // Power down n 
.................... #define  LTC2656_cmd_power_down_all      0x50  // Power down chip (all DAC's and reference) 
.................... #define  LTC2656_cmd_internal_reference  0x60  // Select internal reference (power-up reference) 
.................... #define  LTC2656_cmd_external_reference  0x70  // Select external reference (power-down internal reference) 
.................... #define  LTC2656_cmd_no_operation        0xF0  // No operation 
.................... //LTC2656 DAC addresses 
.................... #define  LTC2656_DAC_A     0x00 
.................... #define  LTC2656_DAC_B     0x01 
.................... #define  LTC2656_DAC_C     0x02 
.................... #define  LTC2656_DAC_D     0x03 
.................... #define  LTC2656_DAC_E     0x04 
.................... #define  LTC2656_DAC_F     0x05 
.................... #define  LTC2656_DAC_G     0x06 
.................... #define  LTC2656_DAC_H     0x07 
.................... #define  LTC2656_DAC_ALL   0x0F 
....................  
.................... //Global calibration variables 
.................... float LTC2656_offset[8]; // DAC offset 
.................... float LTC2656_lsb[8];    // The LTC2656 lsb 
....................  
.................... void LTC2656_write(unsigned int dac_command, unsigned char dac_address, unsigned int dac_code) 
.................... //Write the 16-bit dac_code to the LTC2656 
.................... { 
....................     unsigned char command_byte; 
....................     union{unsigned char b[2];unsigned int w;} data; 
....................     data.w = dac_code;                              // Get dac code 
0369:  BSF    03.5
036A:  BSF    03.6
036B:  MOVF   5E,W
036C:  MOVWF  61
036D:  MOVF   5D,W
036E:  MOVWF  60
....................     command_byte = dac_command | dac_address;       // Build the DAC command byte   
036F:  MOVF   5A,W
0370:  IORWF  5C,W
0371:  MOVWF  5F
....................     output_low (LTC2656_CS);                        // Pull CS low to start transaction 
0372:  BCF    03.6
0373:  BCF    06.5
0374:  BCF    03.5
0375:  BCF    06.5
....................     spi_write(command_byte);                        // Write the command and address  
0376:  MOVF   13,W
0377:  BSF    03.5
0378:  BSF    03.6
0379:  MOVF   5F,W
037A:  BCF    03.5
037B:  BCF    03.6
037C:  MOVWF  13
037D:  BSF    03.5
037E:  RRF    14,W
037F:  BTFSS  03.0
0380:  GOTO   37E
....................     spi_write(data.b[1]);                           // Write the MSB  
0381:  BCF    03.5
0382:  MOVF   13,W
0383:  BSF    03.5
0384:  BSF    03.6
0385:  MOVF   61,W
0386:  BCF    03.5
0387:  BCF    03.6
0388:  MOVWF  13
0389:  BSF    03.5
038A:  RRF    14,W
038B:  BTFSS  03.0
038C:  GOTO   38A
....................     spi_write(data.b[0]);                           // Write the LSB 
038D:  BCF    03.5
038E:  MOVF   13,W
038F:  BSF    03.5
0390:  BSF    03.6
0391:  MOVF   60,W
0392:  BCF    03.5
0393:  BCF    03.6
0394:  MOVWF  13
0395:  BSF    03.5
0396:  RRF    14,W
0397:  BTFSS  03.0
0398:  GOTO   396
....................     output_high(LTC2656_CS);                        // Pull CS high to finish transaction   
0399:  BCF    06.5
039A:  BCF    03.5
039B:  BSF    06.5
.................... } 
039C:  BSF    0A.3
039D:  BCF    0A.4
039E:  GOTO   2DA (RETURN)
....................  
.................... unsigned int LTC2656_code(float dac_voltage, unsigned char dac_address) 
.................... //Calculate a LTC2656 DAC code given the desired output voltage and DAC address (0-7)  
.................... { 
....................     unsigned int dac_code; 
....................     float float_code; 
....................     if (dac_address > 7) 
....................         dac_address = 7;                                                                            // Check DAC address range 
....................     float_code = (dac_voltage - LTC2656_offset[dac_address]) / LTC2656_lsb[dac_address];            // Calculate the DAC code 
....................     float_code = (float_code > (floor(float_code) + 0.5)) ? ceil(float_code) : floor(float_code);   // Round 
....................     dac_code = (unsigned int) (float_code);                                                         // Convert to unsigned integer 
....................     return (dac_code); 
.................... } 
....................  
.................... float LTC2656_voltage(unsigned int dac_code, unsigned char dac_address) 
.................... //Calculate the LTC2656 DAC output voltage given the DAC code and DAC address (0-7) 
.................... { 
....................     float dac_voltage; 
....................     if (dac_address > 7) 
....................         dac_address = 7;                                                                            // Check DAC address range 
....................     dac_voltage = (((float) dac_code) * LTC2656_lsb[dac_address]) + LTC2656_offset[dac_address];    // Calculate the dac_voltage 
....................     return (dac_voltage); 
.................... } 
....................  
.................... void LTC2656_calibrate(unsigned int dac_code1, unsigned int dac_code2, float voltage1, float voltage2, unsigned char dac_address) 
.................... //Calculate the LTC2656 offset and LSB voltage given two measured voltages and their corresponding codes 
.................... { 
....................     if (dac_address > 7) 
....................         dac_address = 7;                                                                            // Check DAC address range 
....................     LTC2656_lsb[dac_address] = (voltage2 - voltage1) / ((float) (dac_code2 - dac_code1));           // Calculate the LSB 
....................     LTC2656_offset[dac_address] = voltage1 - (LTC2656_lsb[dac_address] * dac_code1);                // Calculate the offset 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC2657\LTC2657.h" 
.................... /* 
....................  LTC2657  
....................  Octal I2C 16-/12-Bit Rail-to-Rail DACs with 10ppm/C Max Reference 
....................    
....................  I2C DATA FORMAT (MSB First): 
....................    
....................               Byte #1                                    Byte #2                       Byte #3                             Byte #4 
....................                                                                                        MSB                                 LSB 
....................  LTC2657-16 : START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 W SACK  C3 C2 C1 C0 A3 A2 A1 A0 SACK  D15 D14 D13 D12 D11 D10 D9 D8 SACK  D7 D6 D5 D4 D3 D2 D1 D0 SACK  STOP 
....................  LTC2657-12 : START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 W SACK  C3 C2 C1 C0 A3 A2 A1 A0 SACK  D11 D10 D9  D8  D7  D6  D5 D4 SACK  D3 D2 D1 D0 X  X  X  X  SACK  STOP 
....................  
....................  START: I2C Start 
....................  SAx  : I2C Address 
....................  W    : I2C Write (0) 
....................  SACK : I2C Slave Generated Acknowledge (Active Low) 
....................  Cx   : DAC Command Code 
....................  Ax   : DAC Address (0=DACA,1=DACB,2=DACC,3=DACD,4=DACE,5=DACF,6=DACG,7=DACH,0xFF=All DAC's) 
....................  Dx   : DAC Data Bits   
....................  X    : Don't care 
....................  STOP : I2C Stop 
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 719 $ 
.................... $Date: 2012-10-26 14:22:35 -0700 (Fri, 26 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
.................... */ 
....................  
.................... #ifndef LTC2657_h 
.................... #define LTC2657_h 
....................  
.................... // Address Choices: 
.................... // To choose an address, comment out all options except the  
.................... // configuration on the demo board. 
....................  
....................                                       //  Address assignment 
.................... //LTC2657 I2C Address                 //  AD2       AD1       AD0 
.................... #define LTC2657_I2C_ADDRESS 0x20      //  GND       GND       GND 
.................... //#define LTC2657_I2C_ADDRESS 0x22    //  GND       GND       Float 
.................... //#define LTC2657_I2C_ADDRESS 0x24    //  GND       GND       Vcc 
.................... //#define LTC2657_I2C_ADDRESS 0x26    //  GND       Float     GND 
.................... //#define LTC2657_I2C_ADDRESS 0x40    //  GND       Float     Float 
.................... //#define LTC2657_I2C_ADDRESS 0x42    //  GND       Float     Vcc 
.................... //#define LTC2657_I2C_ADDRESS 0x44    //  GND       Vcc       GND 
.................... //#define LTC2657_I2C_ADDRESS 0x46    //  GND       Vcc       Float 
.................... //#define LTC2657_I2C_ADDRESS 0x60    //  GND       Vcc       Vcc 
.................... //#define LTC2657_I2C_ADDRESS 0x62    //  Float     GND       GND 
.................... //#define LTC2657_I2C_ADDRESS 0x64    //  Float     GND       Float 
.................... //#define LTC2657_I2C_ADDRESS 0x66    //  Float     GND       Vcc 
.................... //#define LTC2657_I2C_ADDRESS 0x80    //  Float     Float     GND 
.................... //#define LTC2657_I2C_ADDRESS 0x82    //  Float     Float     Float 
.................... //#define LTC2657_I2C_ADDRESS 0x84    //  Float     Float     Vcc 
.................... //#define LTC2657_I2C_ADDRESS 0x86    //  Float     Vcc       GND 
.................... //#define LTC2657_I2C_ADDRESS 0xA0    //  Float     Vcc       Float 
.................... //#define LTC2657_I2C_ADDRESS 0xA2    //  Float     Vcc       Vcc 
.................... //#define LTC2657_I2C_ADDRESS 0xA4    //  Vcc       GND       GND 
.................... //#define LTC2657_I2C_ADDRESS 0xA6    //  Vcc       GND       Float 
.................... //#define LTC2657_I2C_ADDRESS 0xC0    //  Vcc       GND       Vcc 
.................... //#define LTC2657_I2C_ADDRESS 0xC2    //  Vcc       Float     GND 
.................... //#define LTC2657_I2C_ADDRESS 0xC4    //  Vcc       Float     Float 
.................... //#define LTC2657_I2C_ADDRESS 0xC6    //  Vcc       Float     Vcc 
.................... //#define LTC2657_I2C_ADDRESS 0xE0    //  Vcc       Vcc       GND 
.................... //#define LTC2657_I2C_ADDRESS 0xE2    //  Vcc       Vcc       Float 
.................... //#define LTC2657_I2C_ADDRESS 0xE6    //  Vcc       Vcc       Vcc 
....................  
.................... //LTC2657 Command Codes 
.................... //OR'd together with the DAC address to form the command byte 
.................... #define  LTC2657_cmd_write               0x00  // Write to input register n 
.................... #define  LTC2657_cmd_update              0x10  // Update (power up) DAC register n 
.................... #define  LTC2657_cmd_write_update        0x30  // Write to input register n, update (power-up) all 
.................... #define  LTC2657_cmd_power_down          0x40  // Power down n 
.................... #define  LTC2657_cmd_power_down_all      0x50  // Power down chip (all DAC's and reference) 
.................... #define  LTC2657_cmd_internal_reference  0x60  // Select internal reference (power-up reference) 
.................... #define  LTC2657_cmd_external_reference  0x70  // Select external reference (power-down internal reference) 
.................... #define  LTC2657_cmd_no_operation        0xF0  // No operation 
....................  
.................... //LTC2657 DAC addresses 
.................... #define  LTC2657_DAC_A     0x00 
.................... #define  LTC2657_DAC_B     0x01 
.................... #define  LTC2657_DAC_C     0x02 
.................... #define  LTC2657_DAC_D     0x03 
.................... #define  LTC2657_DAC_E     0x04 
.................... #define  LTC2657_DAC_F     0x05 
.................... #define  LTC2657_DAC_G     0x06 
.................... #define  LTC2657_DAC_H     0x07 
.................... #define  LTC2657_DAC_ALL   0x0F 
....................  
.................... //global calibration variables 
.................... float LTC2657_offset[8]; // DAC offset 
.................... float LTC2657_lsb[8];    // The LTC2657 lsb 
....................  
.................... unsigned char LTC2657_write(unsigned char i2c_address, unsigned char dac_command, unsigned char dac_address, unsigned int dac_code) 
.................... // Write a 16-bit dac_code to the LTC2657. 
.................... // The function returns the state of the acknowledge bit after the I2C Address write. 0=acknowledge, 1=no acknowledge. 
.................... { 
....................     unsigned char ACK; 
....................     unsigned char command_byte; 
....................     union{unsigned char b[2];unsigned int w;} data; 
....................     data.w = dac_code;                              // Get dac code 
039F:  BSF    03.5
03A0:  BSF    03.6
03A1:  MOVF   5E,W
03A2:  MOVWF  62
03A3:  MOVF   5D,W
03A4:  MOVWF  61
....................     command_byte = dac_command | dac_address;       // Build the DAC command byte 
03A5:  MOVF   5B,W
03A6:  IORWF  5C,W
03A7:  MOVWF  60
....................     i2c_start();                                    // Write an I2C start bit 
03A8:  BCF    03.5
03A9:  BCF    03.6
03AA:  BSF    20.5
03AB:  MOVF   20,W
03AC:  BSF    03.5
03AD:  MOVWF  07
03AE:  MOVLW  04
03AF:  MOVWF  77
03B0:  DECFSZ 77,F
03B1:  GOTO   3B0
03B2:  BCF    03.5
03B3:  BSF    20.3
03B4:  MOVF   20,W
03B5:  BSF    03.5
03B6:  MOVWF  07
03B7:  MOVLW  03
03B8:  MOVWF  77
03B9:  DECFSZ 77,F
03BA:  GOTO   3B9
03BB:  BCF    03.5
03BC:  BCF    07.5
03BD:  BCF    20.5
03BE:  MOVF   20,W
03BF:  BSF    03.5
03C0:  MOVWF  07
03C1:  MOVLW  04
03C2:  MOVWF  77
03C3:  DECFSZ 77,F
03C4:  GOTO   3C3
03C5:  BCF    03.5
03C6:  BCF    07.3
03C7:  BCF    20.3
03C8:  MOVF   20,W
03C9:  BSF    03.5
03CA:  MOVWF  07
....................     ACK = i2c_write(i2c_address & 0xFE);            // Write the I2C 8 bit address and !W bit in the LSB position 
03CB:  BSF    03.6
03CC:  MOVF   5A,W
03CD:  ANDLW  FE
03CE:  MOVWF  63
03CF:  MOVWF  66
03D0:  BCF    03.5
03D1:  BCF    03.6
03D2:  CALL   034
03D3:  MOVF   78,W
03D4:  BSF    03.5
03D5:  BSF    03.6
03D6:  MOVWF  5F
....................     if (!ACK)                                       // Check acknowledge status. 0=acknowledge, 1=no acknowledge 
03D7:  MOVF   5F,F
03D8:  BTFSS  03.2
03D9:  GOTO   3EF
....................     { 
....................         i2c_write(command_byte);                    // Write the command byte 
03DA:  MOVF   60,W
03DB:  MOVWF  66
03DC:  BCF    03.5
03DD:  BCF    03.6
03DE:  CALL   034
....................         i2c_write(data.b[1]);                       // Write the MSB 
03DF:  BSF    03.5
03E0:  BSF    03.6
03E1:  MOVF   62,W
03E2:  MOVWF  66
03E3:  BCF    03.5
03E4:  BCF    03.6
03E5:  CALL   034
....................         i2c_write(data.b[0]);                       // Write the LSB  
03E6:  BSF    03.5
03E7:  BSF    03.6
03E8:  MOVF   61,W
03E9:  MOVWF  66
03EA:  BCF    03.5
03EB:  BCF    03.6
03EC:  CALL   034
03ED:  BSF    03.5
03EE:  BSF    03.6
....................     } 
....................     i2c_stop();                                     // Write an I2C stop bit 
03EF:  BCF    03.5
03F0:  BCF    03.6
03F1:  BCF    20.5
03F2:  MOVF   20,W
03F3:  BSF    03.5
03F4:  MOVWF  07
03F5:  NOP
03F6:  BCF    03.5
03F7:  BSF    20.3
03F8:  MOVF   20,W
03F9:  BSF    03.5
03FA:  MOVWF  07
03FB:  BCF    03.5
03FC:  BTFSS  07.3
03FD:  GOTO   3FC
03FE:  MOVLW  04
03FF:  MOVWF  77
0400:  DECFSZ 77,F
0401:  GOTO   400
0402:  GOTO   403
0403:  NOP
0404:  BSF    20.5
0405:  MOVF   20,W
0406:  BSF    03.5
0407:  MOVWF  07
0408:  MOVLW  04
0409:  MOVWF  77
040A:  DECFSZ 77,F
040B:  GOTO   40A
....................     return (ACK); 
040C:  BSF    03.6
040D:  MOVF   5F,W
040E:  MOVWF  78
.................... } 
040F:  BCF    03.6
0410:  BCF    03.5
0411:  BSF    0A.3
0412:  BCF    0A.4
0413:  GOTO   2EB (RETURN)
....................  
.................... unsigned int LTC2657_code(float dac_voltage, unsigned char dac_address) 
.................... //Calculate a LTC2657 DAC code given the desired output voltage and DAC address (0-7)  
.................... { 
....................     unsigned int dac_code; 
....................     float float_code; 
....................     if (dac_address > 7) 
....................         dac_address = 7;                                                                            // Check DAC address range 
....................     float_code = (dac_voltage - LTC2657_offset[dac_address]) / LTC2657_lsb[dac_address];            // Calculate the DAC code 
....................     float_code = (float_code > (floor(float_code) + 0.5)) ? ceil(float_code) : floor(float_code);   // Round 
....................     dac_code = (unsigned int) (float_code);                                                         // Convert to unsigned integer 
....................     return (dac_code); 
.................... } 
....................  
.................... float LTC2657_voltage(unsigned int dac_code, unsigned char dac_address) 
.................... //Calculate the LTC2657 DAC output voltage given the DAC code and DAC address (0-7) 
.................... { 
....................     float dac_voltage; 
....................     if (dac_address > 7) 
....................         dac_address = 7;                                                                            // Check DAC address range 
....................     dac_voltage = (((float) dac_code) * LTC2657_lsb[dac_address]) + LTC2657_offset[dac_address];    // Calculate the dac_voltage 
....................     return (dac_voltage); 
.................... } 
....................  
.................... void LTC2657_calibrate(unsigned int dac_code1, unsigned int dac_code2, float voltage1, float voltage2, unsigned char dac_address) 
.................... //Calculate the LTC2657 offset and LSB voltage given two measured voltages and their corresponding codes 
.................... { 
....................     if (dac_address > 7) 
....................         dac_address = 7;                                                                            // Check DAC address range 
....................     LTC2657_lsb[dac_address] = (voltage2 - voltage1) / ((float) (dac_code2 - dac_code1));           // Calculate the LSB 
....................     LTC2657_offset[dac_address] = voltage1 - (LTC2657_lsb[dac_address] * dac_code1);                // Calculate the offset 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC2945\LTC2945.h" 
.................... /* 
....................  DC1697 
....................  12-bit Wide Range Power Monitor 
....................   
....................  I2C DATA FORMAT (MSB FIRST); 
....................  
....................  Data Out : 
....................  Byte #1                             Byte #2                             Byte #3                             
....................                                                                                      
....................  START  SA6 SA5 SA4 SA3 SA2 SA1 SA0  W SACK  X  X C5 C4 C3 C2 C1 C0 SACK D7 D6 D5 D4 D3 D2 D1 D0 SACK  STOP 
....................  
....................  
....................  DATA IN:  
....................  Byte #1                                    Byte #2                        Byte #3                        Byte #4                                   Byte #5 
....................                                                                                                          MSB                                       LSB 
....................  START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 W SACK  X  X  C5 C4 C3 C2 C1 C0 START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 R  DIV SIG  D13  D12  D11  D10  D0 D8 SACK   D7 D6 D5 D4 D3  D2  D1  D0  SACK  STOP 
....................  
....................   
....................  START: I2C Start 
....................  SAx  : I2C Address 
....................  W    : I2C Write (0) 
....................  R    : I2C Read  (1) 
....................  SACK : I2C Slave Generated Acknowledge (Active Low) 
....................  Cx   : DAC Command Code 
....................  Ax   : DAC Address  
....................  Dx   : DAC Data Bits   
....................  DIV  : Data Valid 
....................  X    : Don't care 
....................  STOP : I2C Stop 
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 699 $ 
.................... $Date: 2012-10-12 13:52:06 -0700 (Fri, 12 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
.................... */ 
....................  
.................... #ifndef LTC2945_h 
.................... #define LTC2945_h 
....................  
.................... // Address Choices: 
.................... // To choose an address, comment out all options except the  
.................... // configuration on the demo board. 
....................  
....................                                       //  Address assignment 
.................... //LTC2945 I2C Address                 //  AD1       AD0 
.................... //#define LTC2945_I2C_ADDRESS 0xCE    //  High      Low 
.................... //#define LTC2945_I2C_ADDRESS 0xD0    //  Float     High 
.................... //#define LTC2945_I2C_ADDRESS 0xD2    //  High      High 
.................... //#define LTC2945_I2C_ADDRESS 0xD4    //  Float     Float 
.................... //#define LTC2945_I2C_ADDRESS 0xD6    //  Float     Low 
.................... //#define LTC2945_I2C_ADDRESS 0xD8    //  Low       High 
.................... //#define LTC2945_I2C_ADDRESS 0xDA    //  High      Float 
.................... //#define LTC2945_I2C_ADDRESS 0xDC    //  Low       Float 
.................... #define LTC2945_I2C_ADDRESS 0xDE      //  Low       Low 
....................  
.................... #define LTC2945_I2C_MASS_WRITE      0xCC     
.................... #define LTC2945_I2C_ALERT_RESPONSE  0x19    
....................  
.................... //Registers 
.................... #define LTC2945_CONTROL_REG                         0x00 
.................... #define LTC2945_ALERT_REG                           0x01 
.................... #define LTC2945_STATUS_REG                          0x02 
.................... #define LTC2945_FAULT_REG                           0x03 
.................... #define LTC2945_FAULT_CoR_REG                       0x04 
....................  
.................... #define LTC2945_POWER_MSB2_REG                      0x05 
.................... #define LTC2945_POWER_MSB1_REG                      0x06 
.................... #define LTC2945_POWER_LSB_REG                       0x07 
.................... #define LTC2945_MAX_POWER_MSB2_REG                  0x08 
.................... #define LTC2945_MAX_POWER_MSB1_REG                  0x09 
.................... #define LTC2945_MAX_POWER_LSB_REG                   0x0A 
.................... #define LTC2945_MIN_POWER_MSB2_REG                  0x0B 
.................... #define LTC2945_MIN_POWER_MSB1_REG                  0x0C 
.................... #define LTC2945_MIN_POWER_LSB_REG                   0x0D 
.................... #define LTC2945_MAX_POWER_THRESHOLD_MSB2_REG        0x0E 
.................... #define LTC2945_MAX_POWER_THRESHOLD_MSB1_REG        0x0F 
.................... #define LTC2945_MAX_POWER_THRESHOLD_LSB_REG         0x10 
.................... #define LTC2945_MIN_POWER_THRESHOLD_MSB2_REG        0x11 
.................... #define LTC2945_MIN_POWER_THRESHOLD_MSB1_REG        0x12 
.................... #define LTC2945_MIN_POWER_THRESHOLD_LSB_REG         0x13 
....................  
.................... #define LTC2945_DELTA_SENSE_MSB_REG                 0x14 
.................... #define LTC2945_DELTA_SENSE_LSB_REG                 0x15 
.................... #define LTC2945_MAX_DELTA_SENSE_MSB_REG             0x16 
.................... #define LTC2945_MAX_DELTA_SENSE_LSB_REG             0x17 
.................... #define LTC2945_MIN_DELTA_SENSE_MSB_REG             0x18 
.................... #define LTC2945_MIN_DELTA_SENSE_LSB_REG             0x19 
.................... #define LTC2945_MAX_DELTA_SENSE_THRESHOLD_MSB_REG   0x1A 
.................... #define LTC2945_MAX_DELTA_SENSE_THRESHOLD_LSB_REG   0x1B 
.................... #define LTC2945_MIN_DELTA_SENSE_THRESHOLD_MSB_REG   0x1C 
.................... #define LTC2945_MIN_DELTA_SENSE_THRESHOLD_LSB_REG   0x1D 
....................  
.................... #define LTC2945_VIN_MSB_REG                         0x1E 
.................... #define LTC2945_VIN_LSB_REG                         0x1F 
.................... #define LTC2945_MAX_VIN_MSB_REG                     0x20 
.................... #define LTC2945_MAX_VIN_LSB_REG                     0x21 
.................... #define LTC2945_MIN_VIN_MSB_REG                     0x22 
.................... #define LTC2945_MIN_VIN_LSB_REG                     0x23 
.................... #define LTC2945_MAX_VIN_THRESHOLD_MSB_REG           0x24 
.................... #define LTC2945_MAX_VIN_THRESHOLD_LSB_REG           0x25 
.................... #define LTC2945_MIN_VIN_THRESHOLD_MSB_REG           0x26 
.................... #define LTC2945_MIN_VIN_THRESHOLD_LSB_REG           0x27 
....................  
.................... #define LTC2945_ADIN_MSB_REG                        0x28 
.................... #define LTC2945_ADIN_LSB_REG_REG                    0x29 
.................... #define LTC2945_MAX_ADIN_MSB_REG                    0x2A 
.................... #define LTC2945_MAX_ADIN_LSB_REG                    0x2B 
.................... #define LTC2945_MIN_ADIN_MSB_REG                    0x2C 
.................... #define LTC2945_MIN_ADIN_LSB_REG                    0x2D 
.................... #define LTC2945_MAX_ADIN_THRESHOLD_MSB_REG          0x2E 
.................... #define LTC2945_MAX_ADIN_THRESHOLD_LSB_REG          0x2F 
.................... #define LTC2945_MIN_ADIN_THRESHOLD_MSB_REG          0x30 
.................... #define LTC2945_MIN_ADIN_THRESHOLD_LSB_REG          0x31 
....................  
.................... //Snapshot Selection Command 
.................... #define LTC2945_DELTA_SENSE_SNAPSHOT            0x80 
.................... #define LTC2945_VIN_SNAPSHOT                    0xA0 
.................... #define LTC2945_ADIN_SNAPSHOT                   0xC0 
....................  
.................... //Command Codes 
.................... #define LTC2945_CONTINUOUS_MODE                 0x00 
.................... #define LTC2945_SHUTDOWN_MODE                   0x02 
.................... #define LTC2945_TEST_MODE                       0x10 
.................... #define LTC2945_RESET_ALL_FAULTS                0x00 
.................... #define LTC2945_SENSE_MULTIPLIER                0x01 
.................... #define LTC2945_SENSE_MONITOR                   0x04 
....................  
.................... #define LTC2945_MAX_POWER_MSB2_RESET            0x00 
.................... #define LTC2945_MIN_POWER_MSB2_RESET            0xFFFFFF 
.................... #define LTC2945_MAX_DELTA_SENSE_MSB_RESET       0x00 
.................... #define LTC2945_MIN_DELTA_SENSE_MSB_RESET       0xFFFF 
.................... #define LTC2945_MAX_VIN_MSB_RESET               0x00 
.................... #define LTC2945_MIN_VIN_MSB_RESET               0xFFFF 
.................... #define LTC2945_MAX_ADIN_MSB_RESET              0x00 
.................... #define LTC2945_MIN_ADIN_MSB_RESET              0xFFFF 
....................  
.................... #define LTC2945_ENABLE_MAX_POWER_ALERT          0x80 
.................... #define LTC2945_ENABLE_MIN_POWER_ALERT          0x40 
.................... #define LTC2945_DISABLE_MAX_POWER_ALERT         0x7F 
.................... #define LTC2945_DISABLE_MIN_POWER_ALERT         0xBF 
....................  
.................... #define LTC2945_ENABLE_MAX_DELTA_SENSE_ALERT    0x20 
.................... #define LTC2945_ENABLE_MIN_DELTA_SENSE_ALERT    0x10 
.................... #define LTC2945_DISABLE_MAX_DELTA_SENSE_ALERT   0xDF 
.................... #define LTC2945_DISABLE_MIN_DELTA_SENSE_ALERT   0xEF 
....................  
.................... #define LTC2945_ENABLE_MAX_VIN_ALERT            0x08 
.................... #define LTC2945_ENABLE_MIN_VIN_ALERT            0x04 
.................... #define LTC2945_DISABLE_MAX_VIN_ALERT           0xF7 
.................... #define LTC2945_DISABLE_MIN_VIN_ALERT           0xFB 
....................  
.................... #define LTC2945_ENABLE_MAX_ADIN_ALERT           0x02 
.................... #define LTC2945_ENABLE_MIN_ADIN_ALERT           0x01 
.................... #define LTC2945_DISABLE_MAX_ADIN_ALERT          0xFD 
.................... #define LTC2945_DISABLE_MIN_ADIN_ALERT          0xFE 
....................  
.................... //Calibration Variable                                 Units 
.................... float LTC2945_ADIN_lsb = 5.001221E-04;                // V 
.................... float LTC2945_DELTA_SENSE_lsb = 2.5006105E-05;        // V 
.................... float LTC2945_VIN_lsb = 2.5006105E-02;                // V 
.................... float LTC2945_Power_lsb = 6.25305E-07;                // V^2   *VIN_lsb * DELTA_SENSE_lsb 
.................... float LTC2945_ADIN_DELTA_SENSE_lsb = 1.25061E-08;     // V^2  *ADIN_lsb * DELTA_SENSE_lsb  
....................  
.................... unsigned char LTC2945_write(unsigned char i2c_address, unsigned char command, unsigned char code) 
.................... //Write a 8-bit code to the LTC2945. 
.................... //The function returns the state of the acknowledge bit after the I2C Address write. 0=acknowledge, 1=no acknowledge. 
.................... { 
....................     unsigned char ack; 
....................     i2c_start();                                // Write an I2C start bit 
0414:  BSF    20.5
0415:  MOVF   20,W
0416:  BSF    03.5
0417:  MOVWF  07
0418:  MOVLW  04
0419:  MOVWF  77
041A:  DECFSZ 77,F
041B:  GOTO   41A
041C:  BCF    03.5
041D:  BSF    20.3
041E:  MOVF   20,W
041F:  BSF    03.5
0420:  MOVWF  07
0421:  MOVLW  03
0422:  MOVWF  77
0423:  DECFSZ 77,F
0424:  GOTO   423
0425:  BCF    03.5
0426:  BCF    07.5
0427:  BCF    20.5
0428:  MOVF   20,W
0429:  BSF    03.5
042A:  MOVWF  07
042B:  MOVLW  04
042C:  MOVWF  77
042D:  DECFSZ 77,F
042E:  GOTO   42D
042F:  BCF    03.5
0430:  BCF    07.3
0431:  BCF    20.3
0432:  MOVF   20,W
0433:  BSF    03.5
0434:  MOVWF  07
....................     ack = i2c_write(i2c_address & 0xFE);        // Write the I2C 8 bit address with the !W bit in the LSB position 
0435:  BSF    03.6
0436:  MOVF   5A,W
0437:  ANDLW  FE
0438:  MOVWF  5E
0439:  MOVWF  66
043A:  BCF    03.5
043B:  BCF    03.6
043C:  CALL   034
043D:  MOVF   78,W
043E:  BSF    03.5
043F:  BSF    03.6
0440:  MOVWF  5D
....................     if (!ack)                                   // Check acknowledge status. 0=acknowledge, 1=no acknowledge 
0441:  MOVF   5D,F
0442:  BTFSS  03.2
0443:  GOTO   452
....................     { 
....................         i2c_write(command);                     // Write the command byte 
0444:  MOVF   5B,W
0445:  MOVWF  66
0446:  BCF    03.5
0447:  BCF    03.6
0448:  CALL   034
....................         i2c_write(code);                        // Write the MSB 
0449:  BSF    03.5
044A:  BSF    03.6
044B:  MOVF   5C,W
044C:  MOVWF  66
044D:  BCF    03.5
044E:  BCF    03.6
044F:  CALL   034
0450:  BSF    03.5
0451:  BSF    03.6
....................     }    
....................     i2c_stop();                                 // Write an I2C stop bit 
0452:  BCF    03.5
0453:  BCF    03.6
0454:  BCF    20.5
0455:  MOVF   20,W
0456:  BSF    03.5
0457:  MOVWF  07
0458:  NOP
0459:  BCF    03.5
045A:  BSF    20.3
045B:  MOVF   20,W
045C:  BSF    03.5
045D:  MOVWF  07
045E:  BCF    03.5
045F:  BTFSS  07.3
0460:  GOTO   45F
0461:  MOVLW  04
0462:  MOVWF  77
0463:  DECFSZ 77,F
0464:  GOTO   463
0465:  GOTO   466
0466:  NOP
0467:  BSF    20.5
0468:  MOVF   20,W
0469:  BSF    03.5
046A:  MOVWF  07
046B:  MOVLW  04
046C:  MOVWF  77
046D:  DECFSZ 77,F
046E:  GOTO   46D
....................     return(ack);     
046F:  BSF    03.6
0470:  MOVF   5D,W
0471:  MOVWF  78
.................... } 
0472:  BCF    03.6
0473:  BCF    03.5
0474:  BSF    0A.3
0475:  BCF    0A.4
0476:  GOTO   2FA (RETURN)
....................  
.................... unsigned char LTC2945_write_16_bits(unsigned char i2c_address, unsigned char command, unsigned int code) 
.................... //Write a 16-bit code to the LTC2945. 
.................... //The function returns the state of the acknowledge bit after the I2C Address write. 0=acknowledge, 1=no acknowledge. 
.................... { 
....................     unsigned char ack; 
....................     union {unsigned char b[2];long w;} data; 
....................     data.w = code; 
....................     i2c_start();                                // Write an I2C start bit 
....................     ack = i2c_write(i2c_address & 0xFE);        // Write the I2C 8 bit address with the !W bit in the LSB position 
....................     if (!ack)                                   // Check acknowledge status. 0=acknowledge, 1=no acknowledge 
....................     { 
....................         i2c_write(command);                     // Write the command byte 
....................         i2c_write(data.b[1]);                   // Write the MSB 
....................         i2c_write(data.b[0]);                   // Write the LSB 
....................     }    
....................     i2c_stop();                                 // Write an I2C stop bit 
....................     return(ack);     
.................... } 
....................  
.................... unsigned char LTC2945_write_24_bits(unsigned char i2c_address, unsigned char command, long code) 
.................... //Write a 24-bit code to the LTC2945. 
.................... //The function returns the state of the acknowledge bit after the I2C Address write. 0=acknowledge, 1=no acknowledge. 
.................... { 
....................     unsigned char ack; 
....................     union {unsigned char b[3];long w;} data; 
....................     data.w = code; 
....................     i2c_start();                                // Write an I2C start bit 
....................     ack = i2c_write(i2c_address & 0xFE);        // Write the I2C 8 bit address with the !W bit in the LSB position 
....................     if (!ack)                                   // Check acknowledge status. 0=acknowledge, 1=no acknowledge 
....................     { 
....................         i2c_write(command);                     // Write the command byte 
....................         i2c_write(data.b[2]);                   // Write the MSB2 
....................         i2c_write(data.b[1]);                   // Write the MSB1 
....................         i2c_write(data.b[0]);                   // Write the LSB 
....................     }    
....................     i2c_stop();                                 // Write an I2C stop bit 
....................     return(ack);     
.................... } 
....................  
.................... unsigned char LTC2945_read(unsigned char i2c_address, unsigned char command, unsigned char& code) 
.................... //Reads a 8-bit code from LTC2945 
.................... { 
....................     unsigned char ack; 
....................     i2c_start();                                // Write an I2C start bit 
....................     ack = i2c_write(i2c_address & 0xFE);        // Write the I2C 8 bit address and !W bit in the LSB position 
....................     i2c_write(command);                         // Write the command byte 
....................     i2c_start();                                // Write an I2C repeat start 
....................     ack = i2c_write(i2c_address | 0x01);        // Write the I2C 8 bit address and !R bit in the LSB position 
....................     code = i2c_read(1);                         // Reads data with Nack 
....................     i2c_stop();                                 // Write an I2C stop bit 
....................     return(ack);                                // Returns data 
.................... } 
....................  
.................... unsigned char LTC2945_read_12_bits(unsigned char i2c_address, unsigned char command, long& code) 
.................... //Reads a 12-bit code from LTC2945 
.................... { 
....................     unsigned char ack; 
....................     union {unsigned char b[2];long w;} data;    // Combines bytes 
....................     i2c_start();                                // Write an I2C start bit 
....................     ack = i2c_write(i2c_address & 0xFE);        // Write the I2C 8 bit address and !W bit in the LSB position 
....................     i2c_write(command);                         // Write the command byte 
....................     i2c_start();                                // Write an I2C repeat start 
....................     ack = i2c_write(i2c_address | 0x01);        // Write the I2C 8 bit address and !R bit in the LSB position 
....................     data.b[1] = i2c_read(0);                    // Reads data with ACK 
....................     data.b[0] = i2c_read(1);                    // Reads data with Nack 
....................     i2c_stop();                                 // Write an I2C stop bit 
....................     data.w >>= 4;                               // Shifts code 4 bits 
....................     code = data.w; 
....................     return(ack);                                // Returns data 
.................... } 
.................... unsigned char LTC2945_read_16_bits(unsigned char i2c_address, unsigned char command, unsigned int& code) 
.................... //Reads a 16-bit code from LTC2945 
.................... { 
....................     unsigned char ack; 
....................     union {unsigned char b[2];long w;} data;    // Combines bytes 
....................     i2c_start();                                // Write an I2C start bit 
....................     ack = i2c_write(i2c_address & 0xFE);        // Write the I2C 8 bit address and !W bit in the LSB position 
....................     i2c_write(command);                         // Write the command byte 
....................     i2c_start();                                // Write an I2C repeat start 
....................     ack = i2c_write(i2c_address | 0x01);        // Write the I2C 8 bit address and !R bit in the LSB position 
....................     data.b[1] = i2c_read(0);                    // Reads data with ACK 
....................     data.b[0] = i2c_read(1);                    // Reads data with Nack 
....................     i2c_stop();                                 // Write an I2C stop bit 
....................     code = data.w; 
....................     return(ack);                                // Returns data 
.................... } 
....................  
.................... unsigned char LTC2945_read_24_bits(unsigned char i2c_address, unsigned char command, long& code) 
.................... //Reads a 24-bit code from LTC2945 
.................... { 
....................     unsigned char ack; 
....................     union {unsigned char b[4];long w;} data;    // Combines bytes 
....................     i2c_start();                                // Write an I2C start bit 
....................     ack = i2c_write(i2c_address & 0xFE);        // Write the I2C 8 bit address and !W bit in the LSB position 
....................     i2c_write(command);                         // Write the command byte 
....................     i2c_start();                                // Write an I2C repeat start 
....................     ack = i2c_write(i2c_address | 0x01);        // Write the I2C 8 bit address and !R bit in the LSB position 
....................     data.b[2] = i2c_read(0);                    // Reads data with ACK 
....................     data.b[1] = i2c_read(0);                    // Reads data with ACK 
....................     data.b[0] = i2c_read(1);                    // Reads data with Nack 
....................     i2c_stop();                                 // Write an I2C stop bit 
....................     code = data.w; 
....................     return(ack);                                // Returns data 
.................... } 
....................  
.................... float LTC2945_VIN_voltage(long adc_code) 
.................... //Calculate the LTC2945 VIN voltage 
.................... { 
....................     float voltage; 
....................     voltage = (float)adc_code*LTC2945_VIN_lsb; 
....................     return(voltage);    
.................... } 
....................  
.................... float LTC2945_ADIN_voltage(long adc_code) 
.................... //Calculate the LTC2945 ADIN voltage 
.................... { 
....................     float adc_voltage; 
....................     adc_voltage = (float)adc_code*LTC2945_ADIN_lsb; 
....................     return(adc_voltage);    
.................... } 
....................  
.................... float LTC2945_current(long adc_code, float resistor) 
.................... //Calculate the LTC2945 current with a sense resitor 
.................... { 
....................     float voltage, current; 
....................     voltage = (float)adc_code*LTC2945_DELTA_SENSE_lsb; 
....................     current = voltage/resistor; 
....................     return(current);    
.................... } 
....................  
.................... float LTC2945_power(long adc_code, float resistor) 
.................... //Calculate the LTC2945 power 
.................... { 
....................     float voltage, power; 
....................     voltage = (float)adc_code*LTC2945_Power_lsb;            // Units in V^2 
....................     power = voltage/resistor; 
....................     return(power);    
.................... } 
....................  
.................... float LTC2945_ADIN_power(long adc_code, float resistor) 
.................... //Calculate the LTC2945 power with the ADIN 
.................... { 
....................     float voltage, power; 
....................     voltage=(float)adc_code*LTC2945_ADIN_DELTA_SENSE_lsb;   // Units in V^2 
....................     power = voltage/resistor; 
....................     return(power);    
.................... } 
.................... #endif  
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC2991\LTC2991.h" 
.................... /* 
....................  DC1785 
....................  14-bit ADC octal I2C voltage, current, and temprature monitor 
....................  
....................  I2C DATA FORMAT (MSB FIRST); 
....................  
....................  Data Out : 
....................  Byte #1                              Byte #2                             Byte #3                             
....................                                                                                      
....................  START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 W SACK  X  X  X  X  C3 C2 C1 C0 SACK  D7 D6 D5 D4 D3 D2 D1 D0 SACK  STOP 
....................  
....................  
....................  DATA IN:  
....................  (Voltage/Current) 
....................  Byte #1                                    Byte #2                        Byte #3                        Byte #4                                   Byte #5 
....................                                                                                                          MSB                                       LSB 
....................  START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 W SACK  X  X  X  X  C3 C2 C1 C0 START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 R  DIV SIG  D13  D12  D11  D10  D0 D8 SACK   D7 D6 D5 D4 D3  D2  D1  D0  SACK  STOP 
....................  
....................  (Temperature/ Diode Voltage) 
....................  Byte #1                                    Byte #2                        Byte #3                        Byte #4                                   Byte #5 
....................                                                                                                          MSB                                       LSB 
....................  START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 W SACK  X  X  X  X  C3 C2 C1 C0 START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 R  DIV  X  X  D12  D11  D10  D0  D8 SACK      D7 D6 D5 D4 D3  D2  D1  D0  SACK  STOP 
....................  
....................  START: I2C Start 
....................  SAx  : I2C Address 
....................  W    : I2C Write (0) 
....................  R    : I2C Read  (1) 
....................  SACK : I2C Slave Generated Acknowledge (Active Low) 
....................  Cx   : DAC Command Code 
....................  Ax   : DAC Address  
....................  Dx   : DAC Data Bits   
....................  DIV  : Data Valid 
....................  X    : Don't care 
....................  STOP : I2C Stop 
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 699 $ 
.................... $Date: 2012-10-12 13:52:06 -0700 (Fri, 12 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
.................... */ 
....................  
.................... #ifndef LTC2991_h 
.................... #define LTC2991_h 
....................  
.................... // Address Choices: 
.................... // To choose an address, comment out all options except the  
.................... // configuration on the demo board. 
....................  
....................                                       //  Address assignment 
.................... //LTC2991 I2C Address                 //  AD2       AD1       AD0 
.................... #define LTC2991_I2C_ADDRESS 0x90      //  Low       Low       Low 
.................... //#define LTC2991_I2C_ADDRESS 0x92    //  Low       Low       High 
.................... //#define LTC2991_I2C_ADDRESS 0x94    //  Low       High      Low 
.................... //#define LTC2991_I2C_ADDRESS 0x96    //  Low       High      High 
.................... //#define LTC2991_I2C_ADDRESS 0x98    //  High      Low       Low 
.................... //#define LTC2991_I2C_ADDRESS 0x9A    //  High      Low       High 
.................... //#define LTC2991_I2C_ADDRESS 0x9C    //  High      High      Low 
.................... //#define LTC2991_I2C_ADDRESS 0x9E    //  High      High      High 
....................  
.................... //#define LTC2991_I2C_GLOBAL_ADDRESS 0xDE  //  Global Address 
....................  
.................... // Registers 
.................... #define LTC2991_STATUS_LOW_REG              0x00    // Data_Valid Bits(V1 Through V8) 
.................... #define LTC2991_CHANNEL_ENABLE_REG          0x01    // Channel Enable,Vcc, T_internal Conversion Status, Trigger 
.................... #define LTC2991_CONTROL_V1234_REG           0x06    // V1, V2, V3, and V4 Control Register 
.................... #define LTC2991_CONTROL_V5678_REG           0x07    // V5, V6, V7, AND V8 Control Register 
.................... #define LTC2991_PWM_THRESHOLD_Tinternal_REG 0x08    // PWM Threshold and T_internal Control Register 
.................... #define LTC2991_PWM_THRESHOLD_MSB_REG       0x09    // PWM Threshold  
.................... #define LTC2991_V1_MSB_REG                  0x0A    // V1, or T_R1 T MSB 
.................... #define LTC2991_V1_LSB_REG                  0x0B    // V1, or T_R1 T LSB 
.................... #define LTC2991_V2_MSB_REG                  0x0C    // V2, V1-V2, or T_R2 Voltage MSB 
.................... #define LTC2991_V2_LSB_REG                  0x0D    // V2, V1-V2, or T_R2 Voltage LSB 
.................... #define LTC2991_V3_MSB_REG                  0x0E    // V3, or T_R2 T MSB 
.................... #define LTC2991_V3_LSB_REG                  0x0F    // V3, or T_R2 T LSB 
.................... #define LTC2991_V4_MSB_REG                  0x10    // V4,V3-V4, or T_R2 Voltage MSB 
.................... #define LTC2991_V4_LSB_REG                  0x11    // V4,V3-V4, or T_R2 Voltage LSB 
.................... #define LTC2991_V5_MSB_REG                  0x12    // V5, or T_R3 T MSB 
.................... #define LTC2991_V5_LSB_REG                  0x13    // V5, or T_R3 T LSB 
.................... #define LTC2991_V6_MSB_REG                  0x14    // V6, V5-V6, or T_R3 Voltage MSB 
.................... #define LTC2991_V6_LSB_REG                  0x15    // V6, V5-V6, or T_R3 Voltage LSB 
.................... #define LTC2991_V7_MSB_REG                  0x16    // V7, or T_R4 T MSB 
.................... #define LTC2991_V7_LSB_REG                  0x17    // V7, or T_R4 T LSB 
.................... #define LTC2991_V8_MSB_REG                  0x18    // V8,V7-V8, or T_R4 Voltage MSB 
.................... #define LTC2991_V8_LSB_REG                  0x19    // V8,V7-V8, or T_R4 Voltage LSB 
.................... #define LTC2991_T_Internal_MSB_REG          0x1A    // T_Internal MSB 
.................... #define LTC2991_T_Internal_LSB_REG          0x1B    // T_Internal LSB 
.................... #define LTC2991_Vcc_MSB_REG                 0x1C    // Vcc MSB 
.................... #define LTC2991_Vcc_LSB_REG                 0x1D    // Vcc LSB 
....................  
.................... //Commands  
.................... #define LTC2991_ENABLE_ALL_CHANNELS     0xF8 
.................... #define LTC2991_REPEAT_MODE             0x10 
.................... #define LTC2991_DIFFERENTIAL_ENABLE     0x11 
....................  
.................... #define LTC2991_PWM_DISABLE             0x10 
.................... #define LTC2991_PWM_ENABLE              0x30 
.................... #define LTC2991_PWM_INVERT              0x40 
....................  
.................... #define LTC2991_INT_FILTER_ENABLE       0x08 
.................... #define LTC2991_V1_V2_FILTER_ENABLE     0x08 
.................... #define LTC2991_V3_V4_FILTER_ENABLE     0x80 
.................... #define LTC2991_V5_V6_FILTER_ENABLE     0x08 
.................... #define LTC2991_V7_V8_FILTER_ENABLE     0x80 
....................  
.................... #define LTC2991_INT_KELVIN_ENABLE       0x04 
.................... #define LTC2991_V1_V2_KELVIN_ENABLE     0x04 
.................... #define LTC2991_V3_V4_KELVIN_ENABLE     0x40 
.................... #define LTC2991_V5_V6_KELVIN_ENABLE     0x04 
.................... #define LTC2991_V7_V8_KELVIN_ENABLE     0x40 
....................  
.................... #define LTC2991_V1_V2_TEMP_ENABLE       0x02 
.................... #define LTC2991_V3_V4_TEMP_ENABLE       0x20 
.................... #define LTC2991_V5_V6_TEMP_ENABLE       0x02 
.................... #define LTC2991_V7_V8_TEMP_ENABLE       0x20 
....................  
.................... //Calibration Variables                            Units       
.................... float LTC2991_Single_Ended_lsb = 3.05176E-04;   // Volts 
.................... float LTC2991_Differential_lsb = 1.90735E-05;   // Volts 
.................... float LTC2991_Vcc_lsb = 3.05176E-04;            // Volts 
.................... float LTC2991_Temperature_lsb = 0.0625;         // Degrees Temperarure Internal, T_R1 - T_R4 
.................... float LTC2991_Diode_Voltage_lsb = 3.815E-05;    // Volts, T_R1-T_R4  
....................  
.................... unsigned char LTC2991_write(unsigned char i2c_address, unsigned char command, unsigned char code) 
.................... //Write a 8-bit code to the LTC2991. 
.................... //The function returns the state of the acknowledge bit after the I2C Address write. 0=acknowledge, 1=no acknowledge. 
.................... { 
....................  
....................     unsigned char ack; 
....................     i2c_start();                                // Write an I2C start bit 
0477:  BSF    20.5
0478:  MOVF   20,W
0479:  BSF    03.5
047A:  MOVWF  07
047B:  MOVLW  04
047C:  MOVWF  77
047D:  DECFSZ 77,F
047E:  GOTO   47D
047F:  BCF    03.5
0480:  BSF    20.3
0481:  MOVF   20,W
0482:  BSF    03.5
0483:  MOVWF  07
0484:  MOVLW  03
0485:  MOVWF  77
0486:  DECFSZ 77,F
0487:  GOTO   486
0488:  BCF    03.5
0489:  BCF    07.5
048A:  BCF    20.5
048B:  MOVF   20,W
048C:  BSF    03.5
048D:  MOVWF  07
048E:  MOVLW  04
048F:  MOVWF  77
0490:  DECFSZ 77,F
0491:  GOTO   490
0492:  BCF    03.5
0493:  BCF    07.3
0494:  BCF    20.3
0495:  MOVF   20,W
0496:  BSF    03.5
0497:  MOVWF  07
....................     ack = i2c_write(i2c_address & 0xFE);        // Write the I2C 8 bit address with the !W bit in the LSB position 
0498:  BSF    03.6
0499:  MOVF   5A,W
049A:  ANDLW  FE
049B:  MOVWF  5E
049C:  MOVWF  66
049D:  BCF    03.5
049E:  BCF    03.6
049F:  CALL   034
04A0:  MOVF   78,W
04A1:  BSF    03.5
04A2:  BSF    03.6
04A3:  MOVWF  5D
....................     if (!ack)                                   // Check acknowledge status. 0=acknowledge, 1=no acknowledge 
04A4:  MOVF   5D,F
04A5:  BTFSS  03.2
04A6:  GOTO   4B5
....................     { 
....................         i2c_write(command);                     // Write the command byte 
04A7:  MOVF   5B,W
04A8:  MOVWF  66
04A9:  BCF    03.5
04AA:  BCF    03.6
04AB:  CALL   034
....................         i2c_write(code);                        // Write the MSB 
04AC:  BSF    03.5
04AD:  BSF    03.6
04AE:  MOVF   5C,W
04AF:  MOVWF  66
04B0:  BCF    03.5
04B1:  BCF    03.6
04B2:  CALL   034
04B3:  BSF    03.5
04B4:  BSF    03.6
....................     } 
....................     i2c_stop();                                 // Write an I2C stop bit 
04B5:  BCF    03.5
04B6:  BCF    03.6
04B7:  BCF    20.5
04B8:  MOVF   20,W
04B9:  BSF    03.5
04BA:  MOVWF  07
04BB:  NOP
04BC:  BCF    03.5
04BD:  BSF    20.3
04BE:  MOVF   20,W
04BF:  BSF    03.5
04C0:  MOVWF  07
04C1:  BCF    03.5
04C2:  BTFSS  07.3
04C3:  GOTO   4C2
04C4:  MOVLW  04
04C5:  MOVWF  77
04C6:  DECFSZ 77,F
04C7:  GOTO   4C6
04C8:  GOTO   4C9
04C9:  NOP
04CA:  BSF    20.5
04CB:  MOVF   20,W
04CC:  BSF    03.5
04CD:  MOVWF  07
04CE:  MOVLW  04
04CF:  MOVWF  77
04D0:  DECFSZ 77,F
04D1:  GOTO   4D0
....................     return (ack); 
04D2:  BSF    03.6
04D3:  MOVF   5D,W
04D4:  MOVWF  78
.................... } 
04D5:  BCF    03.6
04D6:  BCF    03.5
04D7:  BSF    0A.3
04D8:  BCF    0A.4
04D9:  GOTO   309 (RETURN)
....................  
.................... unsigned char LTC2991_read(unsigned char i2c_address, unsigned char command, int& code) 
.................... //Reads a 16-bit code from LTC2991 
.................... { 
....................     unsigned int ack; 
....................     union {unsigned char b[2];long w;} data;          // Combines bytes 
....................     do 
....................     { 
....................         i2c_start();                                // Write an I2C start bit 
....................         ack = i2c_write(i2c_address & 0xFE);        // Write the I2C 8 bit address and !W bit in the LSB position 
....................         if (!ack) 
....................         { 
....................             i2c_write(command);                     // Write the command byte 
....................             i2c_start(); 
....................             ack = i2c_write(i2c_address | 0x01);    // Write the I2C 8 bit address and !R bit in the LSB position 
....................             if (!ack) 
....................             { 
....................                 data.b[1] = i2c_read(0);            // Reads MSB byte with ACK 
....................                 data.b[0] = i2c_read(1);            // Reads LSB byte with Nack 
....................             } 
....................         } 
....................         i2c_stop();                                 // Write an I2C stop bit 
....................     } while (!(data.b[1] >> 7) && (ack == 0));      // Repeats if received old data 
....................     code = (data.w & 0x7FFF);                       // Removes data valid bit 
....................     return (ack); 
....................  
.................... } 
....................  
.................... float LTC2991_voltage_Single_Ended(long code) 
.................... //Calculate the LTC2991 input voltage and calculates Vcc 
.................... { 
....................     float voltage; 
....................     int sign = 1; 
....................     if (code >> 14) 
....................     { 
....................         code = (code ^ 0x7FFF) + 1;                 // Converts two's complement 
....................         sign = -1; 
....................     } 
....................     code = (code & 0x3FFF); 
....................     voltage = ((float) code) * LTC2991_Single_Ended_lsb * sign; 
....................     return (voltage); 
.................... } 
.................... float LTC2991_Vcc(long code) 
.................... //Calculate the LTC2991 input voltage and calculates Vcc 
.................... { 
....................     float voltage; 
....................     int sign = 1; 
....................     if (code >> 14) 
....................     { 
....................         code = (code ^ 0x7FFF) + 1;                 // Converts two's complement 
....................         sign = -1; 
....................     } 
....................     voltage = (((float) code) * LTC2991_Single_Ended_lsb * sign) + 2.5; 
....................     return (voltage); 
.................... } 
.................... float LTC2991_voltage_Differential(long code) 
.................... //Calculate the LTC2991 input voltage. 
.................... { 
....................     float voltage; 
....................     int sign = 1; 
....................     if (code >> 14) 
....................     { 
....................         code = (code ^ 0x7FFF) + 1;                 // Converts two's complement 
....................         sign = -1; 
....................     } 
....................     voltage = ((float) code) * LTC2991_Differential_lsb * sign; 
....................     return (voltage); 
.................... } 
.................... float LTC2991_Temperature(long code) 
.................... { 
....................     float temperature; 
....................     code = (code & 0x1FFF);                         // Removes first 3 bits 
....................     temperature = ((float) code) * LTC2991_Temperature_lsb; 
....................     return (temperature); 
.................... } 
.................... float LTC2991_Diode_Voltage(long code) 
.................... { 
....................     float voltage; 
....................     code = (code & 0x1FFF);                         // Removes first 3 bits 
....................     voltage = ((float) code) * LTC2991_Diode_Voltage_lsb; 
....................     return (voltage); 
.................... } 
.................... #endif 
....................  
.................... #include "..\..\LTSketchbook\Libraries\LTC4151\LTC4151.h" 
.................... /* 
....................  DC1208A 
....................  High Voltage I2C Current and Voltage Monitor 
....................   
....................  I2C DATA FORMAT (MSB FIRST); 
....................  
....................  Data Out : 
....................  Byte #1                              Byte #2                             Byte #3                             
....................                                                                                      
....................  START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 W SACK  X  X  X  X  C3 C2 C1 C0 SACK  D7 D6 D5 D4 D3 D2 D1 D0 SACK  STOP 
....................  
....................  DATA IN:  
....................  Byte #1                                    Byte #2                        Byte #3                        Byte #4                                   Byte #5 
....................                                                                                                          MSB                                       LSB 
....................  START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 W SACK  X  X  X  X  C3 C2 C1 C0 START  SA6 SA5 SA4 SA3 SA2 SA1 SA0 R  D15 D14  D13  D12  D11  D10  D0 D8 SACK   D7 D6 D5 D4 D3  D2  D1  D0  SACK  STOP 
....................  
....................  START: I2C Start 
....................  SAx  : I2C Address 
....................  W    : I2C Write (0) 
....................  R    : I2C Read  (1) 
....................  SACK : I2C Slave Generated Acknowledge (Active Low) 
....................  Cx   : DAC Command Code 
....................  Ax   : DAC Address 
....................  Dx   : DAC Data Bits   
....................  X    : Don't care 
....................  STOP : I2C Stop 
....................  
.................... DATA TYPES: 
.................... char  = 1 byte 
.................... int   = 2 bytes 
.................... long  = 4 bytes 
.................... float = 4 bytes  
....................    
.................... REVISION HISTORY 
.................... $Revision: 699 $ 
.................... $Date: 2012-10-12 13:52:06 -0700 (Fri, 12 Oct 2012) $ 
....................    
.................... LICENSE   
.................... Permission to freely use, copy, modify, and distribute this software for any  
.................... purpose with or without fee is hereby granted, provided that the above  
.................... copyright notice and this permission notice appear in all copies: 
....................   
.................... THIS SOFTWARE IS PROVIDED "AS IS" AND LTC DISCLAIMS ALL WARRANTIES 
.................... INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO 
.................... EVENT SHALL LTC BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL 
.................... DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ANY USE OF SAME, INCLUDING 
.................... ANY LOCS OF USE OR DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
.................... OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  
.................... PERFORMANCE OF THIS SOFTWARE. 
....................  
.................... Copyright 2012 Linear Technology Corp. (LTC) 
.................... */ 
....................  
.................... #ifndef LTC4151_h 
.................... #define LTC4151_h 
....................  
.................... // Address Choices: 
.................... // To choose an address, comment out all options except the  
.................... // configuration on the demo board. 
....................  
....................                                       //  Address assignment 
.................... //LTC4151 I2C Address                 //  AD1       AD0 
.................... //#define LTC4151_I2C_ADDRESS 0xCE    //  High      Low 
.................... //#define LTC4151_I2C_ADDRESS 0xD0    //  Float     High 
.................... //#define LTC4151_I2C_ADDRESS 0xD2    //  High      High 
.................... //#define LTC4151_I2C_ADDRESS 0xD4    //  Float     Float 
.................... //#define LTC4151_I2C_ADDRESS 0xD6    //  Float     Low 
.................... //#define LTC4151_I2C_ADDRESS 0xD8    //  Low       High 
.................... //#define LTC4151_I2C_ADDRESS 0xDA    //  High      Float 
.................... //#define LTC4151_I2C_ADDRESS 0xDC    //  Low       Float 
.................... #define LTC4151_I2C_ADDRESS 0xDE      //  Low       Low 
....................  
.................... //#define LTC4151_I2C_GLOBAL_ADDRESS 0xCC  //  Global Address 
....................  
.................... // Registers 
.................... #define LTC4151_SENSE_MSB_REG       0x00 // ADC Current Sense Voltage Data (8 MSB) ** 
.................... #define LTC4151_SENSE_LSB_REG       0x01 // ADC Current Sense Voltage Data (4 LSB) ** 
.................... #define LTC4151_VIN_MSB_REG         0x02 // ADC V_IN Voltage Data (8 MSB) ** 
.................... #define LTC4151_VIN_LSB_REG         0x03 // ADC V_IN Voltage Data (4 LSB) ** 
.................... #define LTC4151_ADIN_MSB_REG        0x04 // ADC ADIN Voltage Data (8 MSB) ** 
.................... #define LTC4151_ADIN_LSB_REG        0x05 // ADC ADIN Voltage Data (4 LSB) ** 
.................... #define LTC4151_CONTROL_REG         0x06 // Controls ADC Operation Mode and Test Mode 
....................  
....................                                      // **Writable if LTC4151_Control b4 is set. 
.................... #define LTC4151_SENSE_CHANNEL_REG   0x00 // ADC Sense Channel For Snapshot Mode 
.................... #define LTC4151_VIN_CHANNEL_REG     0x20 // ADC V_IN Channel For Snapshot Mode 
.................... #define LTC4151_ADIN_CHANNEL_REG    0x40 // ADC ADIN Channel For Snapshot Mode 
....................  
.................... //Commands 
.................... #define LTC4151_CONTINUOUS_MODE 0x00 
.................... #define LTC4151_SNAPSHOT_MODE   0x80 
....................  
.................... float LTC4151_sense_lsb = 2E-02; 
.................... float LTC4151_vin_lsb = 2.5E-02; 
.................... float LTC4151_adin_lsb = 5E-01; 
....................  
.................... unsigned char LTC4151_write(unsigned char i2c_address, unsigned char command, unsigned char code) 
.................... //Write a 8-bit code to the LTC4151. 
.................... //The function returns the state of the acknowledge bit after the I2C Address write. 0=acknowledge, 1=no acknowledge. 
.................... { 
....................     unsigned char ack; 
....................     i2c_start();                                    // Write an I2C start bit 
04DA:  BSF    20.5
04DB:  MOVF   20,W
04DC:  BSF    03.5
04DD:  MOVWF  07
04DE:  MOVLW  04
04DF:  MOVWF  77
04E0:  DECFSZ 77,F
04E1:  GOTO   4E0
04E2:  BCF    03.5
04E3:  BSF    20.3
04E4:  MOVF   20,W
04E5:  BSF    03.5
04E6:  MOVWF  07
04E7:  MOVLW  03
04E8:  MOVWF  77
04E9:  DECFSZ 77,F
04EA:  GOTO   4E9
04EB:  BCF    03.5
04EC:  BCF    07.5
04ED:  BCF    20.5
04EE:  MOVF   20,W
04EF:  BSF    03.5
04F0:  MOVWF  07
04F1:  MOVLW  04
04F2:  MOVWF  77
04F3:  DECFSZ 77,F
04F4:  GOTO   4F3
04F5:  BCF    03.5
04F6:  BCF    07.3
04F7:  BCF    20.3
04F8:  MOVF   20,W
04F9:  BSF    03.5
04FA:  MOVWF  07
....................     ack = i2c_write(i2c_address & 0xFE);            // Write the I2C 8 bit address with the !W bit in the LSB position 
04FB:  BSF    03.6
04FC:  MOVF   5A,W
04FD:  ANDLW  FE
04FE:  MOVWF  5E
04FF:  MOVWF  66
0500:  BCF    03.5
0501:  BCF    03.6
0502:  CALL   034
0503:  MOVF   78,W
0504:  BSF    03.5
0505:  BSF    03.6
0506:  MOVWF  5D
....................     if (!ack)                                       // Check acknowledge status. 0=acknowledge, 1=no acknowledge 
0507:  MOVF   5D,F
0508:  BTFSS  03.2
0509:  GOTO   518
....................     { 
....................         i2c_write(command);                         // Write the command byte 
050A:  MOVF   5B,W
050B:  MOVWF  66
050C:  BCF    03.5
050D:  BCF    03.6
050E:  CALL   034
....................         i2c_write(code);                            // Write the code 
050F:  BSF    03.5
0510:  BSF    03.6
0511:  MOVF   5C,W
0512:  MOVWF  66
0513:  BCF    03.5
0514:  BCF    03.6
0515:  CALL   034
0516:  BSF    03.5
0517:  BSF    03.6
....................     } 
....................     i2c_stop();                                     // Write an I2C stop bit 
0518:  BCF    03.5
0519:  BCF    03.6
051A:  BCF    20.5
051B:  MOVF   20,W
051C:  BSF    03.5
051D:  MOVWF  07
051E:  NOP
051F:  BCF    03.5
0520:  BSF    20.3
0521:  MOVF   20,W
0522:  BSF    03.5
0523:  MOVWF  07
0524:  BCF    03.5
0525:  BTFSS  07.3
0526:  GOTO   525
0527:  MOVLW  04
0528:  MOVWF  77
0529:  DECFSZ 77,F
052A:  GOTO   529
052B:  GOTO   52C
052C:  NOP
052D:  BSF    20.5
052E:  MOVF   20,W
052F:  BSF    03.5
0530:  MOVWF  07
0531:  MOVLW  04
0532:  MOVWF  77
0533:  DECFSZ 77,F
0534:  GOTO   533
....................     return (ack); 
0535:  BSF    03.6
0536:  MOVF   5D,W
0537:  MOVWF  78
.................... } 
0538:  BCF    03.6
0539:  BCF    03.5
053A:  BSF    0A.3
053B:  BCF    0A.4
053C:  GOTO   318 (RETURN)
....................  
.................... unsigned char LTC4151_read(unsigned char i2c_address, unsigned char command, int& code) 
.................... //Reads a 16-bit code from LTC4151 
.................... { 
....................     unsigned int ack = 0; 
....................     union {unsigned char b[2];long w;} data;        // Combines bytes 
....................     i2c_start();                                    // Write an I2C start bit 
....................     ack = i2c_write(i2c_address & 0xFE);            // Write the I2C 8 bit address and !W bit in the LSB position 
....................     if (!ack) 
....................     { 
....................         i2c_write(command);                         // Write the command byte 
....................         i2c_start(); 
....................         ack = i2c_write(i2c_address | 0x01);        // Write the I2C 8 bit address and !R bit in the LSB position 
....................         if (!ack) 
....................         { 
....................             data.b[1] = i2c_read(0);                // Reads data with ACK 
....................             data.b[0] = i2c_read(1);                // Reads data with Nack 
....................         } 
....................     } 
....................     i2c_stop();                                     // Write an I2C stop bit 
....................     code = data.w >> 3;                             // Removes last 4 bits 
....................     return (ack); 
.................... } 
....................  
.................... float LTC4151_sense_Current(long code, float resistor) 
.................... //Calculates the LTC4151 sense current in mA with resistor 
.................... { 
....................     float voltage, current; 
....................     voltage = (((float) (code >> 1)) - 1) * LTC4151_sense_lsb; 
....................     current = voltage / resistor; 
....................     return (current); 
.................... } 
....................  
.................... float LTC4151_Vin_voltage(long code) 
.................... //Calculates the LTC4151 V_IN voltage 
.................... { 
....................     float voltage; 
....................     voltage = ((float) (code >> 1) - 1) * LTC4151_vin_lsb; 
....................     return (voltage); 
.................... } 
....................  
.................... float LTC4151_ADIN_voltage(long code) 
.................... //Calculates the LTC4151 ADIN in mV 
.................... { 
....................     float voltage; 
....................     voltage = ((float) (code >> 1) - 1) * LTC4151_adin_lsb; 
....................     return (voltage); 
.................... } 
.................... #endif 
....................  
....................  
.................... void main() 
.................... { 
*
0800:  CLRF   04
0801:  BCF    03.7
0802:  MOVLW  1F
0803:  ANDWF  03,F
0804:  MOVLW  FF
0805:  MOVWF  20
0806:  MOVLW  F2
0807:  MOVWF  24
0808:  MOVLW  12
0809:  MOVWF  23
080A:  MOVLW  03
080B:  MOVWF  22
080C:  MOVLW  71
080D:  MOVWF  21
080E:  CLRF   28
080F:  CLRF   27
0810:  CLRF   26
0811:  CLRF   25
0812:  CLRF   2C
0813:  CLRF   2B
0814:  CLRF   2A
0815:  CLRF   29
0816:  MOVLW  A0
0817:  MOVWF  30
0818:  MOVLW  1A
0819:  MOVWF  2F
081A:  MOVLW  03
081B:  MOVWF  2E
081C:  MOVLW  75
081D:  MOVWF  2D
081E:  CLRF   34
081F:  CLRF   33
0820:  CLRF   32
0821:  CLRF   31
0822:  MOVLW  01
0823:  MOVWF  38
0824:  CLRF   37
0825:  MOVLW  20
0826:  MOVWF  36
0827:  MOVLW  6A
0828:  MOVWF  35
0829:  CLRF   3C
082A:  CLRF   3B
082B:  CLRF   3A
082C:  CLRF   39
082D:  CLRF   40
082E:  CLRF   3F
082F:  MOVLW  20
0830:  MOVWF  3E
0831:  MOVLW  64
0832:  MOVWF  3D
0833:  CLRF   44
0834:  CLRF   43
0835:  CLRF   42
0836:  CLRF   41
0837:  MOVLW  9C
0838:  MOVWF  48
0839:  CLRF   47
083A:  MOVLW  20
083B:  MOVWF  46
083C:  MOVLW  6F
083D:  MOVWF  45
083E:  CLRF   4C
083F:  CLRF   4B
0840:  CLRF   4A
0841:  CLRF   49
0842:  CLRF   50
0843:  CLRF   4F
0844:  MOVLW  20
0845:  MOVWF  4E
0846:  MOVLW  64
0847:  MOVWF  4D
0848:  CLRF   54
0849:  CLRF   53
084A:  CLRF   52
084B:  CLRF   51
084C:  CLRF   58
084D:  CLRF   57
084E:  MOVLW  58
084F:  MOVWF  56
0850:  MOVLW  83
0851:  MOVWF  55
0852:  MOVLW  31
0853:  MOVWF  5C
0854:  MOVLW  08
0855:  MOVWF  5B
0856:  MOVLW  2C
0857:  MOVWF  5A
0858:  MOVLW  98
0859:  MOVWF  59
085A:  MOVLW  6F
085B:  MOVWF  60
085C:  MOVLW  12
085D:  MOVWF  5F
085E:  MOVLW  03
085F:  MOVWF  5E
0860:  MOVLW  75
0861:  MOVWF  5D
0862:  CLRF   64
0863:  CLRF   63
0864:  CLRF   62
0865:  CLRF   61
0866:  MOVLW  A0
0867:  MOVWF  7E
0868:  MOVLW  1A
0869:  MOVWF  7D
086A:  MOVLW  03
086B:  MOVWF  7C
086C:  MOVLW  74
086D:  MOVWF  7B
086E:  MOVLW  34
086F:  BSF    03.5
0870:  BSF    03.6
0871:  MOVWF  13
0872:  MOVLW  C4
0873:  MOVWF  12
0874:  MOVLW  51
0875:  MOVWF  11
0876:  MOVLW  6F
0877:  MOVWF  10
0878:  MOVLW  9A
0879:  MOVWF  17
087A:  MOVLW  D9
087B:  MOVWF  16
087C:  MOVLW  4C
087D:  MOVWF  15
087E:  MOVLW  79
087F:  MOVWF  14
0880:  MOVLW  A2
0881:  MOVWF  1B
0882:  MOVLW  DA
0883:  MOVWF  1A
0884:  MOVLW  27
0885:  MOVWF  19
0886:  MOVLW  6A
0887:  MOVWF  18
0888:  MOVLW  69
0889:  MOVWF  1F
088A:  MOVLW  DA
088B:  MOVWF  1E
088C:  MOVLW  56
088D:  MOVWF  1D
088E:  MOVLW  64
088F:  MOVWF  1C
0890:  MOVLW  08
0891:  MOVWF  23
0892:  CLRF   22
0893:  MOVLW  20
0894:  MOVWF  21
0895:  MOVLW  73
0896:  MOVWF  20
0897:  MOVLW  08
0898:  MOVWF  27
0899:  CLRF   26
089A:  MOVLW  20
089B:  MOVWF  25
089C:  MOVLW  6F
089D:  MOVWF  24
089E:  MOVLW  08
089F:  MOVWF  2B
08A0:  CLRF   2A
08A1:  MOVLW  20
08A2:  MOVWF  29
08A3:  MOVLW  73
08A4:  MOVWF  28
08A5:  CLRF   2F
08A6:  CLRF   2E
08A7:  CLRF   2D
08A8:  MOVLW  7B
08A9:  MOVWF  2C
08AA:  MOVLW  40
08AB:  MOVWF  33
08AC:  MOVLW  03
08AD:  MOVWF  32
08AE:  MOVLW  20
08AF:  MOVWF  31
08B0:  MOVLW  70
08B1:  MOVWF  30
08B2:  MOVLW  0A
08B3:  MOVWF  37
08B4:  MOVLW  D7
08B5:  MOVWF  36
08B6:  MOVLW  23
08B7:  MOVWF  35
08B8:  MOVLW  79
08B9:  MOVWF  34
08BA:  MOVLW  CD
08BB:  MOVWF  3B
08BC:  MOVLW  CC
08BD:  MOVWF  3A
08BE:  MOVLW  4C
08BF:  MOVWF  39
08C0:  MOVLW  79
08C1:  MOVWF  38
08C2:  CLRF   3F
08C3:  CLRF   3E
08C4:  CLRF   3D
08C5:  MOVLW  7E
08C6:  MOVWF  3C
08C7:  BCF    03.6
08C8:  BSF    1F.0
08C9:  BSF    1F.1
08CA:  BSF    1F.2
08CB:  BCF    1F.3
08CC:  MOVLW  07
08CD:  MOVWF  1C
08CE:  MOVLW  30
08CF:  BSF    03.6
08D0:  MOVWF  4A
08D1:  MOVWF  4C
08D2:  CLRF   4B
08D3:  MOVWF  4E
08D4:  MOVWF  4F
08D5:  CLRF   50
08D6:  MOVLW  80
08D7:  MOVWF  52
08D8:  CLRF   51
08D9:  MOVLW  A0
08DA:  MOVWF  53
....................   int adc_code; 
....................   long adc_code_2; 
....................   long adc_reading; 
....................   unsigned char adc_command=0x30; 
....................   int adc_command_2=0x3000; 
....................   unsigned char code; 
....................   unsigned char command=0x30; 
.................... 	unsigned char dac_command=0x30; 
.................... 	unsigned char dac_address=0x00; 
.................... 	unsigned int  dac_code=0x8000; 
.................... 	unsigned char i2c_address=0xa0; 
.................... 	unsigned char ack; 
.................... 	char overrange; 
.................... 	float result; 
....................  
....................   adc_code=LTC1867_read(adc_command); 
08DB:  MOVF   4A,W
08DC:  MOVWF  5A
08DD:  BCF    0A.3
08DE:  BCF    03.5
08DF:  BCF    03.6
08E0:  GOTO   004
08E1:  BSF    0A.3
08E2:  MOVF   79,W
08E3:  BSF    03.5
08E4:  BSF    03.6
08E5:  MOVWF  41
08E6:  MOVF   78,W
08E7:  MOVWF  40
.................... 	ack=LTC2309_read(i2c_address,adc_command,adc_code); 
08E8:  MOVF   53,W
08E9:  MOVWF  5A
08EA:  MOVF   4A,W
08EB:  MOVWF  5B
*
09AD:  MOVF   78,W
09AE:  MOVWF  54
.................... 	adc_reading=LTC2418_read(adc_command); 
09AF:  MOVF   4A,W
09B0:  MOVWF  5A
09B1:  BCF    0A.3
09B2:  BCF    03.5
09B3:  BCF    03.6
09B4:  GOTO   108
09B5:  BSF    0A.3
09B6:  MOVF   7A,W
09B7:  BSF    03.5
09B8:  BSF    03.6
09B9:  MOVWF  49
09BA:  MOVF   79,W
09BB:  MOVWF  48
09BC:  MOVF   78,W
09BD:  MOVWF  47
09BE:  MOVF   77,W
09BF:  MOVWF  46
.................... 	adc_reading=LTC2449_read(adc_command_2); 
09C0:  MOVF   4C,W
09C1:  MOVWF  5B
09C2:  MOVF   4B,W
09C3:  MOVWF  5A
09C4:  BCF    0A.3
09C5:  BCF    03.5
09C6:  BCF    03.6
09C7:  GOTO   186
09C8:  BSF    0A.3
09C9:  MOVF   7A,W
09CA:  BSF    03.5
09CB:  BSF    03.6
09CC:  MOVWF  49
09CD:  MOVF   79,W
09CE:  MOVWF  48
09CF:  MOVF   78,W
09D0:  MOVWF  47
09D1:  MOVF   77,W
09D2:  MOVWF  46
.................... 	ack=LTC2461_read(i2c_address,adc_command,adc_code_2); 
09D3:  MOVF   53,W
09D4:  MOVWF  5A
09D5:  MOVF   4A,W
09D6:  MOVWF  5B
*
0A8A:  MOVF   78,W
0A8B:  MOVWF  54
.................... 	adc_reading=LTC2484_read(adc_command); 
0A8C:  MOVF   4A,W
0A8D:  MOVWF  5A
0A8E:  BCF    0A.3
0A8F:  BCF    03.5
0A90:  BCF    03.6
0A91:  GOTO   20D
0A92:  BSF    0A.3
0A93:  MOVF   7A,W
0A94:  BSF    03.5
0A95:  BSF    03.6
0A96:  MOVWF  49
0A97:  MOVF   79,W
0A98:  MOVWF  48
0A99:  MOVF   78,W
0A9A:  MOVWF  47
0A9B:  MOVF   77,W
0A9C:  MOVWF  46
.................... 	LTC2640_write(dac_command,dac_code); 
0A9D:  MOVF   4F,W
0A9E:  MOVWF  5A
0A9F:  MOVF   52,W
0AA0:  MOVWF  5C
0AA1:  MOVF   51,W
0AA2:  MOVWF  5B
0AA3:  BCF    0A.3
0AA4:  BCF    03.5
0AA5:  BCF    03.6
0AA6:  GOTO   28B
0AA7:  BSF    0A.3
....................   LTC2654_write(dac_command,dac_address,dac_code); 
0AA8:  BSF    03.5
0AA9:  BSF    03.6
0AAA:  CLRF   5B
0AAB:  MOVF   4F,W
0AAC:  MOVWF  5A
0AAD:  MOVF   50,W
0AAE:  MOVWF  5C
0AAF:  MOVF   52,W
0AB0:  MOVWF  5E
0AB1:  MOVF   51,W
0AB2:  MOVWF  5D
0AB3:  BCF    0A.3
0AB4:  BCF    03.5
0AB5:  BCF    03.6
0AB6:  GOTO   2BE
0AB7:  BSF    0A.3
....................   ack=LTC2655_write(i2c_address,dac_command,dac_address,dac_code); 
0AB8:  BSF    03.5
0AB9:  BSF    03.6
0ABA:  MOVF   53,W
0ABB:  MOVWF  5A
0ABC:  MOVF   4F,W
0ABD:  MOVWF  5B
0ABE:  MOVF   50,W
0ABF:  MOVWF  5C
0AC0:  MOVF   52,W
0AC1:  MOVWF  5E
0AC2:  MOVF   51,W
0AC3:  MOVWF  5D
0AC4:  BCF    0A.3
0AC5:  BCF    03.5
0AC6:  BCF    03.6
0AC7:  GOTO   2F4
0AC8:  BSF    0A.3
0AC9:  MOVF   78,W
0ACA:  BSF    03.5
0ACB:  BSF    03.6
0ACC:  MOVWF  54
....................   LTC2656_write(dac_command,dac_address,dac_code); 
0ACD:  CLRF   5B
0ACE:  MOVF   4F,W
0ACF:  MOVWF  5A
0AD0:  MOVF   50,W
0AD1:  MOVWF  5C
0AD2:  MOVF   52,W
0AD3:  MOVWF  5E
0AD4:  MOVF   51,W
0AD5:  MOVWF  5D
0AD6:  BCF    0A.3
0AD7:  BCF    03.5
0AD8:  BCF    03.6
0AD9:  GOTO   369
0ADA:  BSF    0A.3
....................   ack=LTC2657_write(i2c_address,dac_command,dac_address,dac_code); 
0ADB:  BSF    03.5
0ADC:  BSF    03.6
0ADD:  MOVF   53,W
0ADE:  MOVWF  5A
0ADF:  MOVF   4F,W
0AE0:  MOVWF  5B
0AE1:  MOVF   50,W
0AE2:  MOVWF  5C
0AE3:  MOVF   52,W
0AE4:  MOVWF  5E
0AE5:  MOVF   51,W
0AE6:  MOVWF  5D
0AE7:  BCF    0A.3
0AE8:  BCF    03.5
0AE9:  BCF    03.6
0AEA:  GOTO   39F
0AEB:  BSF    0A.3
0AEC:  MOVF   78,W
0AED:  BSF    03.5
0AEE:  BSF    03.6
0AEF:  MOVWF  54
....................   ack=LTC2945_write(i2c_address,command,code); 
0AF0:  MOVF   53,W
0AF1:  MOVWF  5A
0AF2:  MOVF   4E,W
0AF3:  MOVWF  5B
0AF4:  MOVF   4D,W
0AF5:  MOVWF  5C
0AF6:  BCF    0A.3
0AF7:  BCF    03.5
0AF8:  BCF    03.6
0AF9:  GOTO   414
0AFA:  BSF    0A.3
0AFB:  MOVF   78,W
0AFC:  BSF    03.5
0AFD:  BSF    03.6
0AFE:  MOVWF  54
....................   ack=LTC2991_write(i2c_address,command,code); 
0AFF:  MOVF   53,W
0B00:  MOVWF  5A
0B01:  MOVF   4E,W
0B02:  MOVWF  5B
0B03:  MOVF   4D,W
0B04:  MOVWF  5C
0B05:  BCF    0A.3
0B06:  BCF    03.5
0B07:  BCF    03.6
0B08:  GOTO   477
0B09:  BSF    0A.3
0B0A:  MOVF   78,W
0B0B:  BSF    03.5
0B0C:  BSF    03.6
0B0D:  MOVWF  54
....................   ack=LTC4151_write(i2c_address,command,code); 
0B0E:  MOVF   53,W
0B0F:  MOVWF  5A
0B10:  MOVF   4E,W
0B11:  MOVWF  5B
0B12:  MOVF   4D,W
0B13:  MOVWF  5C
0B14:  BCF    0A.3
0B15:  BCF    03.5
0B16:  BCF    03.6
0B17:  GOTO   4DA
0B18:  BSF    0A.3
0B19:  MOVF   78,W
0B1A:  BSF    03.5
0B1B:  BSF    03.6
0B1C:  MOVWF  54
.................... } 
0B1D:  SLEEP

Configuration Fuses:
   Word  1: 3F33   RC NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
